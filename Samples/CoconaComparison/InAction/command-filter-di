#!/usr/bin/dotnet --
// command-filter-di - Nuru DI version demonstrating mediator pipeline behaviors
#:project ../../../Source/TimeWarp.Nuru/TimeWarp.Nuru.csproj
#:project ../../../Source/TimeWarp.Nuru.Logging/TimeWarp.Nuru.Logging.csproj

using TimeWarp.Nuru;
using TimeWarp.Nuru.Logging;
using TimeWarp.Mediator;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using static System.Console;

// Create app with DI and pipeline behaviors - fully fluent!
NuruApp app = new NuruAppBuilder()
  .UseConsoleLogging()
  .AddDependencyInjection(config =>
  {
    config.RegisterServicesFromAssembly(typeof(HelloCommand).Assembly);
  })
  .ConfigureServices(services =>
  {
    services.AddTransient(typeof(IPipelineBehavior<,>), typeof(LoggingBehavior<,>));
    services.AddTransient(typeof(IPipelineBehavior<,>), typeof(ValidationBehavior<,>));
  })
  .AddRoute<HelloCommand>("hello")
  .AddAutoHelp()
  .Build();

return await app.RunAsync(args);

// Command with multiple pipeline behaviors applied
public sealed class HelloCommand : IRequest
{
  internal sealed class Handler : IRequestHandler<HelloCommand>
  {
    public async Task Handle(HelloCommand request, CancellationToken cancellationToken)
    {
      WriteLine($"Hello Konnichiwa");
      await Task.CompletedTask;
    }
  }
}

// Logging behavior (similar to CommandFilter)
public sealed class LoggingBehavior<TRequest, TResponse> : TimeWarp.Mediator.IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest
{
  private readonly ILogger<LoggingBehavior<TRequest, TResponse>> Logger;

  public LoggingBehavior(ILogger<LoggingBehavior<TRequest, TResponse>> logger)
  {
    Logger = logger;
  }

  public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
  {
    var requestName = typeof(TRequest).Name;
    Logger.LogInformation($"[LoggingBehavior] Before Command: {requestName}");

    try
    {
      var response = await next();
      Logger.LogInformation($"[LoggingBehavior] After Command: {requestName}");
      return response;
    }
    catch (Exception ex)
    {
      Logger.LogError($"[LoggingBehavior] Exception: {ex.GetType().FullName}: {ex.Message}");
      throw;
    }
  }
}

// Validation behavior (another cross-cutting concern)
public sealed class ValidationBehavior<TRequest, TResponse> : TimeWarp.Mediator.IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest
{
  private readonly ILogger<ValidationBehavior<TRequest, TResponse>> Logger;

  public ValidationBehavior(ILogger<ValidationBehavior<TRequest, TResponse>> logger)
  {
    Logger = logger;
  }

  public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
  {
    Logger.LogInformation($"[ValidationBehavior] Validating: {typeof(TRequest).Name}");

    // In a real application, you would perform validation here
    // For example, using FluentValidation or custom validation logic

    return await next();
  }
}