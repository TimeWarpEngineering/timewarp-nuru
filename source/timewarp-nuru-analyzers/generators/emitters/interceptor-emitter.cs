// Main emitter that generates the RunAsync interceptor method.
// This is the entry point for code emission, coordinating all other emitters.

namespace TimeWarp.Nuru.Generators;

using System.Text;

/// <summary>
/// Emits the complete generated interceptor source file.
/// This is the main entry point for the emission phase.
/// </summary>
internal static class InterceptorEmitter
{
  /// <summary>
  /// Generates the complete source code for the interceptor.
  /// </summary>
  /// <param name="model">The application model containing all route definitions.</param>
  /// <returns>The generated C# source code.</returns>
  public static string Emit(AppModel model)
  {
    StringBuilder sb = new();

    EmitHeader(sb);
    EmitInterceptsLocationAttribute(sb);
    EmitNamespaceAndUsings(sb);
    EmitClassStart(sb);
    EmitInterceptsLocation(sb, model.InterceptSites);
    EmitMethodSignature(sb);
    EmitMethodBody(sb, model);
    EmitClassEnd(sb, model);

    return sb.ToString();
  }

  /// <summary>
  /// Emits the InterceptsLocationAttribute definition.
  /// In .NET 10 / C# 14, interceptors use the new versioned constructor:
  /// InterceptsLocationAttribute(int version, string data)
  /// We use 'file' scope so it doesn't conflict with other generators that may define it.
  /// </summary>
  private static void EmitInterceptsLocationAttribute(StringBuilder sb)
  {
    sb.AppendLine("namespace System.Runtime.CompilerServices");
    sb.AppendLine("{");
    sb.AppendLine("  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]");
    sb.AppendLine("  file sealed class InterceptsLocationAttribute : global::System.Attribute");
    sb.AppendLine("  {");
    sb.AppendLine("    public InterceptsLocationAttribute(int version, string data)");
    sb.AppendLine("    {");
    sb.AppendLine("      Version = version;");
    sb.AppendLine("      Data = data;");
    sb.AppendLine("    }");
    sb.AppendLine();
    sb.AppendLine("    public int Version { get; }");
    sb.AppendLine("    public string Data { get; }");
    sb.AppendLine("  }");
    sb.AppendLine("}");
    sb.AppendLine();
  }

  /// <summary>
  /// Emits the auto-generated header comment and nullable enable.
  /// </summary>
  private static void EmitHeader(StringBuilder sb)
  {
    sb.AppendLine("// <auto-generated/>");
    sb.AppendLine("// This code was generated by TimeWarp.Nuru V2 source generator.");
    sb.AppendLine("// Do not modify this file directly.");
    sb.AppendLine("#nullable enable");
    sb.AppendLine();
  }

  /// <summary>
  /// Emits the namespace declaration and using statements.
  /// Uses block-scoped namespace to be compatible with the InterceptsLocationAttribute
  /// which is in a separate namespace block in the same file.
  /// </summary>
  private static void EmitNamespaceAndUsings(StringBuilder sb)
  {
    sb.AppendLine("namespace TimeWarp.Nuru.Generated");
    sb.AppendLine("{");
    sb.AppendLine();
    sb.AppendLine("using global::System.Reflection;");
    sb.AppendLine("using global::System.Runtime.CompilerServices;");
    sb.AppendLine("using global::System.Threading.Tasks;");
    sb.AppendLine("using global::TimeWarp.Nuru;");
    sb.AppendLine("using global::TimeWarp.Terminal;");
    sb.AppendLine();
  }

  /// <summary>
  /// Emits the file-scoped static class declaration.
  /// </summary>
  private static void EmitClassStart(StringBuilder sb)
  {
    sb.AppendLine("file static class GeneratedInterceptor");
    sb.AppendLine("{");
  }

  /// <summary>
  /// Emits [InterceptsLocation] attributes for all RunAsync call sites.
  /// Uses the new .NET 10 / C# 14 versioned encoding via InterceptableLocation.
  /// </summary>
  private static void EmitInterceptsLocation(StringBuilder sb, ImmutableArray<InterceptSiteModel> sites)
  {
    // Emit an attribute for each call site so all RunAsync calls are intercepted
    foreach (InterceptSiteModel site in sites)
    {
      // Use the Roslyn-generated attribute syntax which handles all encoding
      // Format: [global::System.Runtime.CompilerServices.InterceptsLocationAttribute(version, "data")]
      sb.AppendLine(CultureInfo.InvariantCulture, $"  {site.GetAttributeSyntax()}");
    }
  }

  /// <summary>
  /// Emits the method signature for the intercepted RunAsync method.
  /// Must match the original NuruCoreApp.RunAsync(string[] args) signature exactly.
  /// </summary>
  private static void EmitMethodSignature(StringBuilder sb)
  {
    sb.AppendLine("  public static async Task<int> RunAsync_Intercepted");
    sb.AppendLine("  (");
    sb.AppendLine("    this NuruCoreApp app,");
    sb.AppendLine("    string[] args");
    sb.AppendLine("  )");
    sb.AppendLine("  {");
  }

  /// <summary>
  /// Emits the complete method body including all route matching logic.
  /// </summary>
  private static void EmitMethodBody(StringBuilder sb, AppModel model)
  {
    // Built-in flags: --help, --version, --capabilities
    EmitBuiltInFlags(sb, model);

    // Route matching - emit in specificity order (highest first)
    int routeIndex = 0;
    foreach (RouteDefinition route in model.RoutesBySpecificity)
    {
      RouteMatcherEmitter.Emit(sb, route, routeIndex);
      routeIndex++;
    }

    // No match fallback
    EmitNoMatch(sb);
  }

  /// <summary>
  /// Emits handling for built-in flags (--help, --version, --capabilities).
  /// </summary>
  private static void EmitBuiltInFlags(StringBuilder sb, AppModel model)
  {
    // --help flag
    if (model.HasHelp)
    {
      sb.AppendLine("    // Built-in: --help");
      sb.AppendLine("    if (args is [\"--help\" or \"-h\"])");
      sb.AppendLine("    {");
      sb.AppendLine("      PrintHelp(app.Terminal);");
      sb.AppendLine("      return 0;");
      sb.AppendLine("    }");
      sb.AppendLine();
    }

    // --version flag (always available)
    sb.AppendLine("    // Built-in: --version");
    sb.AppendLine("    if (args is [\"--version\"])");
    sb.AppendLine("    {");
    sb.AppendLine("      PrintVersion(app.Terminal);");
    sb.AppendLine("      return 0;");
    sb.AppendLine("    }");
    sb.AppendLine();

    // --capabilities flag (always available for AI tools)
    sb.AppendLine("    // Built-in: --capabilities (for AI tools)");
    sb.AppendLine("    if (args is [\"--capabilities\"])");
    sb.AppendLine("    {");
    sb.AppendLine("      PrintCapabilities(app.Terminal);");
    sb.AppendLine("      return 0;");
    sb.AppendLine("    }");
    sb.AppendLine();
  }

  /// <summary>
  /// Emits the no-match fallback code.
  /// </summary>
  private static void EmitNoMatch(StringBuilder sb)
  {
    sb.AppendLine("    // No route matched");
    sb.AppendLine("    await app.Terminal.WriteErrorLineAsync(\"Unknown command. Use --help for usage.\").ConfigureAwait(false);");
    sb.AppendLine("    return 1;");
    sb.AppendLine("  }");
  }

  /// <summary>
  /// Emits the closing of the class and helper methods.
  /// </summary>
  private static void EmitClassEnd(StringBuilder sb, AppModel model)
  {
    sb.AppendLine();
    HelpEmitter.Emit(sb, model);
    sb.AppendLine();
    VersionEmitter.Emit(sb, model);
    sb.AppendLine();
    CapabilitiesEmitter.Emit(sb, model);
    sb.AppendLine("}"); // Close class
    sb.AppendLine("}"); // Close namespace
  }
}
