# V2 Generator Phase 4: Emitters

## Description

Create emitter classes that transform the `AppModel` IR into generated C# source code. The main output is an interceptor method that replaces `RunAsync()` at compile time.

## Parent

#265 Epic: V2 Source Generator Implementation

## Key References

**IMPORTANT: Read these before starting:**

1. **Architecture Document:**
   `.agent/workspace/2024-12-25T14-00-00_v2-source-generator-architecture.md`
   - Full pipeline design (Locate → Extract → Emit)
   - Generated code structure (lines 519-606)
   - InterceptsLocation attribute usage

2. **Models (Phase 1 - input to emitters):**
   `source/timewarp-nuru-analyzers/generators/models/`
   - `app-model.cs` - Top-level IR with Routes, Behaviors, Services
   - `route-definition.cs` - Route with Segments, Handler, MessageType
   - `handler-definition.cs` - HandlerKind (Delegate/Mediator/Method), ReturnType
   - `segment-definition.cs` - LiteralDefinition, ParameterDefinition, OptionDefinition
   - `intercept-site-model.cs` - FilePath, Line, Column for [InterceptsLocation]

3. **Extractors (Phase 3 - produce AppModel):**
   `source/timewarp-nuru-analyzers/generators/extractors/`
   - `app-extractor.cs` - Main orchestrator, returns AppModel
   - `fluent-chain-extractor.cs` - Populates AppModelBuilder
   - `pattern-string-extractor.cs` - Converts patterns to segments
   - `handler-extractor.cs` - Creates HandlerDefinition

4. **Reference Emitter (old implementation):**
   `source/timewarp-nuru-analyzers/reference-only/emitters/runtime-code-emitter.cs`
   - `EscapeString()` - Escape strings for C# literals
   - `EscapeXmlComment()` - Escape XML comment text
   - `AppendLine()` - Helper for formatted output
   - `EmitSegmentMatchers()` - Pattern for segment emission

5. **Interceptor Attribute:**
   The generated code uses `[InterceptsLocation]` to replace RunAsync calls:
   ```csharp
   [System.Runtime.CompilerServices.InterceptsLocation(
     @"C:\path\to\Program.cs", line: 15, character: 16)]
   ```

## Technical Notes

### Namespace Conflict
Due to `TimeWarp.Nuru.SyntaxNode` shadowing `Microsoft.CodeAnalysis.SyntaxNode`, use:
```csharp
using RoslynSyntaxNode = Microsoft.CodeAnalysis.SyntaxNode;
```

### Coding Standards
Follow `documentation/developer/standards/csharp-coding.md`:
- PascalCase for private fields (no underscore prefix)
- 2-space indentation
- Allman bracket style
- No `var` keyword

### StringBuilder Pattern
All emitters should use StringBuilder for efficient string building:
```csharp
StringBuilder sb = new();
sb.AppendLine("// <auto-generated/>");
// ... build code ...
return sb.ToString();
```

## Checklist

### Commit 4.1: Create core emitters (4 files)
- [x] `generators/emitters/interceptor-emitter.cs` - Main entry, emits `RunAsync_Generated`
- [x] `generators/emitters/route-matcher-emitter.cs` - Pattern matching code per route
- [x] `generators/emitters/handler-invoker-emitter.cs` - Handler invocation code
- [x] `generators/emitters/service-resolver-emitter.cs` - Service resolution code

### Commit 4.2: Create feature emitters (3 files)
- [x] `generators/emitters/help-emitter.cs` - `--help` output generation
- [x] `generators/emitters/version-emitter.cs` - `--version` output
- [x] `generators/emitters/capabilities-emitter.cs` - `--capabilities` JSON response
- [x] Verify build succeeds

## Detailed Design

### InterceptorEmitter (Main Entry)

The `InterceptorEmitter` is the primary emitter that coordinates all others:

```csharp
public static string Emit(AppModel model)
{
  StringBuilder sb = new();
  
  // 1. File header and usings
  EmitHeader(sb);
  
  // 2. Namespace and class declaration
  EmitClassStart(sb);
  
  // 3. [InterceptsLocation] attribute
  EmitInterceptsLocation(sb, model.InterceptSite);
  
  // 4. Method signature
  EmitMethodSignature(sb);
  
  // 5. Built-in flags (--help, --version, --capabilities)
  if (model.HasHelp) HelpEmitter.Emit(sb, model);
  VersionEmitter.Emit(sb, model);
  CapabilitiesEmitter.Emit(sb, model);
  
  // 6. Route matching (sorted by specificity)
  foreach (RouteDefinition route in model.RoutesBySpecificity)
  {
    RouteMatcherEmitter.Emit(sb, route);
  }
  
  // 7. No match fallback
  EmitNoMatch(sb);
  
  // 8. Close method and class
  EmitClassEnd(sb);
  
  return sb.ToString();
}
```

### Output Structure

```csharp
// <auto-generated/>
#nullable enable

namespace TimeWarp.Nuru.Generated;

using System.Runtime.CompilerServices;

file static class GeneratedInterceptor
{
  [InterceptsLocation(@"C:\...\Program.cs", line: 15, character: 16)]
  public static async Task<int> RunAsync_Intercepted(
    this NuruCoreApp app,
    string[] args,
    CancellationToken cancellationToken = default)
  {
    // Built-in flags
    if (args is ["--help"])
    {
      PrintHelp(app.Terminal);
      return 0;
    }
    if (args is ["--version"])
    {
      PrintVersion(app.Terminal);
      return 0;
    }
    if (args is ["--capabilities"])
    {
      PrintCapabilities(app.Terminal);
      return 0;
    }
    
    // Route: status
    if (args is ["status"])
    {
      string result = "healthy";
      app.Terminal.WriteLine(result);
      return 0;
    }
    
    // Route: greet {name}
    if (args is ["greet", var name])
    {
      // Handler invocation (from HandlerInvokerEmitter)
      string result = $"Hello, {name}!";
      app.Terminal.WriteLine(result);
      return 0;
    }
    
    // Route: deploy {env} --force,-f
    if (args.Length >= 2 && args[0] == "deploy")
    {
      string env = args[1];
      bool force = args.Contains("--force") || args.Contains("-f");
      // Handler invocation
      await Deploy(env, force);
      return 0;
    }
    
    // No match
    app.Terminal.WriteError("Unknown command. Use --help for usage.");
    return 1;
  }
  
  private static void PrintHelp(ITerminal terminal) { ... }
  private static void PrintVersion(ITerminal terminal) { ... }
  private static void PrintCapabilities(ITerminal terminal) { ... }
}
```

### RouteMatcherEmitter

Generates pattern matching for each route type:

**Literal-only routes (simplest):**
```csharp
if (args is ["status"])
```

**Routes with parameters:**
```csharp
if (args is ["greet", var name])
```

**Routes with options:**
```csharp
if (args.Length >= 1 && args[0] == "deploy")
{
  // Parse remaining args for parameters and options
}
```

**Catch-all parameters:**
```csharp
if (args.Length >= 1 && args[0] == "exec")
{
  string[] remaining = args[1..];
}
```

### HandlerInvokerEmitter

Generates handler invocation based on HandlerKind:

**Delegate handlers:**
```csharp
// Direct call (handler code captured at extraction)
string result = handlerLambda(param1, param2);
```

**Mediator handlers:**
```csharp
var request = new GreetQuery { Name = name };
Unit result = await app.Mediator.Send(request, cancellationToken);
```

**Method handlers:**
```csharp
// Resolve containing type if needed
var handler = app.Services.GetRequiredService<HandlerType>();
await handler.HandleMethod(param1, param2);
```

### ServiceResolverEmitter

Generates service resolution for injected parameters:

```csharp
// For handler with service parameters
ILogger logger = app.Services.GetRequiredService<ILogger>();
IFoo foo = app.Services.GetRequiredService<IFoo>();
```

### HelpEmitter

Generates help text from routes:

```csharp
private static void PrintHelp(ITerminal terminal)
{
  terminal.WriteLine("Usage: myapp [command] [options]");
  terminal.WriteLine();
  terminal.WriteLine("Commands:");
  terminal.WriteLine("  status           Check application status");
  terminal.WriteLine("  greet {name}     Greet someone by name");
  terminal.WriteLine("  deploy {env}     Deploy to environment");
  terminal.WriteLine();
  terminal.WriteLine("Options:");
  terminal.WriteLine("  --help           Show this help");
  terminal.WriteLine("  --version        Show version");
}
```

### CapabilitiesEmitter

Generates JSON capabilities for AI tools:

```csharp
private static void PrintCapabilities(ITerminal terminal)
{
  terminal.WriteLine("""
  {
    "name": "myapp",
    "description": "My application",
    "commands": [
      {"pattern": "status", "description": "...", "type": "query"},
      {"pattern": "deploy {env}", "description": "...", "type": "command"}
    ]
  }
  """);
}
```

## Testing Strategy

After emitters are created, verify with:
1. Unit tests for each emitter (Phase 6)
2. Manual inspection of generated code
3. Build verification
4. Integration test: compile generated code

## Notes from Reference Implementation

The `runtime-code-emitter.cs` shows patterns for:
- String escaping (`EscapeString`, `EscapeXmlComment`)
- Formatted line output (`AppendLine` helper)
- Segment matcher emission
- Handling optional constructor arguments

Key differences for Phase 4:
- Reference emitter creates Endpoint objects; we create interceptor method
- Reference emitter uses existing runtime types; we generate inline code
- Reference emitter doesn't handle pattern matching; we use C# patterns
