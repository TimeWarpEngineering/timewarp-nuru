#!/usr/bin/dotnet --
// command-filter-di - Nuru DI version demonstrating mediator pipeline behaviors
#:project ../../../Source/TimeWarp.Nuru/TimeWarp.Nuru.csproj
#:project ../../../Source/TimeWarp.Nuru.Logging/TimeWarp.Nuru.Logging.csproj
#:package Mediator.Abstractions
#:package Mediator.SourceGenerator

using TimeWarp.Nuru;
using Mediator;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using static System.Console;

// Create app with DI and pipeline behaviors - fully fluent!
NuruApp app = new NuruAppBuilder()
  .UseConsoleLogging()
  .AddDependencyInjection()
  .ConfigureServices(services =>
  {
    services.AddMediator();
    // For AOT/runfile scenarios, use explicit generic registrations
    services.AddSingleton<IPipelineBehavior<HelloCommand, Unit>, LoggingBehavior<HelloCommand, Unit>>();
    services.AddSingleton<IPipelineBehavior<HelloCommand, Unit>, ValidationBehavior<HelloCommand, Unit>>();
  })
  .Map<HelloCommand>("hello")
  .AddAutoHelp()
  .Build();

return await app.RunAsync(args);

// Command with multiple pipeline behaviors applied
public sealed class HelloCommand : IRequest
{
  internal sealed class Handler : IRequestHandler<HelloCommand>
  {
    public ValueTask<Unit> Handle(HelloCommand request, CancellationToken cancellationToken)
    {
      WriteLine($"Hello Konnichiwa");
      return default;
    }
  }
}

// Logging behavior (similar to CommandFilter)
public sealed class LoggingBehavior<TMessage, TResponse> : IPipelineBehavior<TMessage, TResponse>
    where TMessage : IMessage
{
  private readonly ILogger<LoggingBehavior<TMessage, TResponse>> Logger;

  public LoggingBehavior(ILogger<LoggingBehavior<TMessage, TResponse>> logger)
  {
    Logger = logger;
  }

  public async ValueTask<TResponse> Handle(TMessage message, MessageHandlerDelegate<TMessage, TResponse> next, CancellationToken cancellationToken)
  {
    string requestName = typeof(TMessage).Name;
    Logger.LogInformation($"[LoggingBehavior] Before Command: {requestName}");

    try
    {
      TResponse response = await next(message, cancellationToken);
      Logger.LogInformation($"[LoggingBehavior] After Command: {requestName}");
      return response;
    }
    catch (Exception ex)
    {
      Logger.LogError($"[LoggingBehavior] Exception: {ex.GetType().FullName}: {ex.Message}");
      throw;
    }
  }
}

// Validation behavior (another cross-cutting concern)
public sealed class ValidationBehavior<TMessage, TResponse> : IPipelineBehavior<TMessage, TResponse>
    where TMessage : IMessage
{
  private readonly ILogger<ValidationBehavior<TMessage, TResponse>> Logger;

  public ValidationBehavior(ILogger<ValidationBehavior<TMessage, TResponse>> logger)
  {
    Logger = logger;
  }

  public async ValueTask<TResponse> Handle(TMessage message, MessageHandlerDelegate<TMessage, TResponse> next, CancellationToken cancellationToken)
  {
    Logger.LogInformation($"[ValidationBehavior] Validating: {typeof(TMessage).Name}");

    // In a real application, you would perform validation here
    // For example, using FluentValidation or custom validation logic

    return await next(message, cancellationToken);
  }
}
