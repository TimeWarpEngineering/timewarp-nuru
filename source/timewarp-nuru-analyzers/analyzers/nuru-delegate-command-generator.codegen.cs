namespace TimeWarp.Nuru;

/// <summary>
/// Code generation methods for the delegate command generator.
/// </summary>
public partial class NuruDelegateCommandGenerator
{
  /// <summary>
  /// Generates the source code for all Command classes.
  /// </summary>
  private static string GenerateCommandClasses(List<DelegateCommandInfo> commands)
  {
    System.Text.StringBuilder sb = new();

    sb.AppendLine("// <auto-generated/>");
    sb.AppendLine("// Generated by TimeWarp.Nuru.Analyzers - NuruDelegateCommandGenerator");
    sb.AppendLine("// DO NOT EDIT");
    sb.AppendLine();
    sb.AppendLine("#nullable enable");
    sb.AppendLine();
    sb.AppendLine("namespace TimeWarp.Nuru.Generated;");
    sb.AppendLine();

    foreach (DelegateCommandInfo command in commands)
    {
      GenerateCommandClass(sb, command);
      sb.AppendLine();
    }

    return sb.ToString();
  }

  private static void GenerateCommandClass(System.Text.StringBuilder sb, DelegateCommandInfo command)
  {
    // Determine the interface based on message type
    string interfaceType = command.MessageType switch
    {
      GeneratedMessageType.Query => $"global::Mediator.IQuery<{command.ReturnType}>",
      GeneratedMessageType.IdempotentCommand => $"global::Mediator.ICommand<{command.ReturnType}>, global::TimeWarp.Nuru.IIdempotent",
      _ => $"global::Mediator.ICommand<{command.ReturnType}>"
    };

    string classDescription = command.MessageType == GeneratedMessageType.Query
      ? "Generated Query class for delegate route."
      : "Generated Command class for delegate route.";

    sb.AppendLine("/// <summary>");
    sb.Append(CultureInfo.InvariantCulture, $"/// {classDescription}");
    sb.AppendLine();
    sb.AppendLine("/// </summary>");
    sb.AppendLine("[global::System.CodeDom.Compiler.GeneratedCode(\"TimeWarp.Nuru.Analyzers\", \"1.0.0\")]");
    sb.Append(CultureInfo.InvariantCulture, $"public sealed class {command.ClassName} : {interfaceType}");
    sb.AppendLine();
    sb.AppendLine("{");

    // Generate properties
    foreach (CommandPropertyInfo prop in command.Properties)
    {
      // Only add ? if nullable AND type doesn't already end with ?
      // (Nullable<T> types display as "T?" so we'd get "T??" otherwise)
      string nullableMarker = prop.IsNullable && !prop.TypeName.EndsWith('?') ? "?" : "";
      string defaultValue = prop.DefaultValue is not null ? $" = {prop.DefaultValue};" : "";

      sb.Append(CultureInfo.InvariantCulture, $"  public {prop.TypeName}{nullableMarker} {prop.Name} {{ get; set; }}{defaultValue}");
      sb.AppendLine();
    }

    // Generate nested Handler class if handler info is available
    if (command.Handler is not null)
    {
      sb.AppendLine();
      GenerateHandlerClass(sb, command);
    }

    sb.AppendLine("}");
  }

  /// <summary>
  /// Generates the nested Handler class inside the Command/Query class.
  /// </summary>
  private static void GenerateHandlerClass(System.Text.StringBuilder sb, DelegateCommandInfo command)
  {
    HandlerInfo handler = command.Handler!;

    // Get DI parameters (non-route params)
    ImmutableArray<ParameterClassification> diParams =
      [.. handler.Parameters.Where(p => p.IsDiParam)];

    // Determine handler interface based on message type
    string handlerInterface = command.MessageType == GeneratedMessageType.Query
      ? $"global::Mediator.IQueryHandler<{command.ClassName}, {command.ReturnType}>"
      : $"global::Mediator.ICommandHandler<{command.ClassName}, {command.ReturnType}>";

    string handlerDescription = command.MessageType == GeneratedMessageType.Query
      ? "Generated Handler for this query."
      : "Generated Handler for this command.";

    // Handler class declaration
    sb.AppendLine("  /// <summary>");
    sb.Append(CultureInfo.InvariantCulture, $"  /// {handlerDescription}");
    sb.AppendLine();
    sb.AppendLine("  /// </summary>");
    sb.Append(CultureInfo.InvariantCulture, $"  public sealed class Handler : {handlerInterface}");
    sb.AppendLine();
    sb.AppendLine("  {");

    // Generate DI fields (PascalCase per coding standard)
    foreach (ParameterClassification diParam in diParams)
    {
      string fieldName = ToPascalCase(diParam.Name);
      sb.Append(CultureInfo.InvariantCulture, $"    private readonly {diParam.TypeFullName} {fieldName};");
      sb.AppendLine();
    }

    // Generate constructor if there are DI params
    if (diParams.Length > 0)
    {
      sb.AppendLine();
      sb.AppendLine("    public Handler");
      sb.AppendLine("    (");

      for (int i = 0; i < diParams.Length; i++)
      {
        ParameterClassification p = diParams[i];
        string comma = i < diParams.Length - 1 ? "," : "";
        sb.Append(CultureInfo.InvariantCulture, $"      {p.TypeFullName} {p.Name}{comma}");
        sb.AppendLine();
      }

      sb.AppendLine("    )");
      sb.AppendLine("    {");

      foreach (ParameterClassification p in diParams)
      {
        sb.Append(CultureInfo.InvariantCulture, $"      {ToPascalCase(p.Name)} = {p.Name};");
        sb.AppendLine();
      }

      sb.AppendLine("    }");
    }

    // Generate Handle method
    sb.AppendLine();
    string asyncKeyword = handler.IsAsync ? "async " : "";
    sb.Append(CultureInfo.InvariantCulture, $"    public {asyncKeyword}global::System.Threading.Tasks.ValueTask<{command.ReturnType}> Handle");
    sb.AppendLine();
    sb.AppendLine("    (");
    sb.Append(CultureInfo.InvariantCulture, $"      {command.ClassName} request,");
    sb.AppendLine();
    sb.AppendLine("      global::System.Threading.CancellationToken cancellationToken");
    sb.AppendLine("    )");
    sb.AppendLine("    {");

    // Add the rewritten lambda body
    string[] bodyLines = handler.LambdaBody.Split('\n');
    foreach (string line in bodyLines)
    {
      string trimmedLine = line.TrimEnd('\r');
      if (!string.IsNullOrWhiteSpace(trimmedLine))
      {
        sb.Append(CultureInfo.InvariantCulture, $"      {trimmedLine.TrimStart()}");
        sb.AppendLine();
      }
    }

    // Add return statement for void returns if not already present
    if (command.ReturnType == "global::Mediator.Unit" && !handler.LambdaBody.Contains("return", StringComparison.Ordinal))
    {
      if (handler.IsAsync)
      {
        sb.AppendLine("      return global::Mediator.Unit.Value;");
      }
      else
      {
        sb.AppendLine("      return default;");
      }
    }

    sb.AppendLine("    }");
    sb.AppendLine("  }");
  }

  /// <summary>
  /// Gets the return type for ICommand&lt;T&gt;.
  /// </summary>
  private static string GetCommandReturnType(DelegateSignature signature)
  {
    // void or Task → Unit
    if (signature.ReturnType.IsVoid)
      return "global::Mediator.Unit";

    if (signature.ReturnType.IsTask)
    {
      // Task → Unit
      if (signature.ReturnType.TaskResultType is null)
        return "global::Mediator.Unit";

      // Task<T> → T
      return signature.ReturnType.TaskResultType.FullName;
    }

    // T → T
    return signature.ReturnType.FullName;
  }

  /// <summary>
  /// Gets the default value expression for a property type.
  /// </summary>
  private static string? GetDefaultValue(DelegateParameterInfo param)
  {
    // Nullable types don't need explicit default
    if (param.IsNullable)
      return null;

    // Arrays need empty array
    if (param.IsArray)
      return "[]";

    // String needs string.Empty
    if (param.Type.FullName == "global::System.String" || param.Type.FullName == "string")
      return "string.Empty";

    // Value types have implicit defaults (int = 0, bool = false, etc.)
    return null;
  }
}
