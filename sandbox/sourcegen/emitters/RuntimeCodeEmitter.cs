// sandbox/sourcegen/emitters/RuntimeCodeEmitter.cs
// Emits runtime C# code from RouteDefinition.
//
// This is the core of Step-4: taking the design-time model and generating
// the runtime structures that were manually constructed in Step-2.
//
// Agent: Amina
// Task: #242-step-4

namespace TimeWarp.Nuru.SourceGen.Emitters;

using System.Text;

/// <summary>
/// Emits runtime C# code from a RouteDefinition.
/// The generated code creates segment matchers, parameter extractors, and invokers.
/// </summary>
public static class RuntimeCodeEmitter
{
  /// <summary>
  /// Configuration for code emission.
  /// </summary>
  public record EmitOptions(
    string Namespace = "Generated",
    string ClassName = "GeneratedRoutes",
    bool IncludeRuntimeTypes = true,
    int IndentSpaces = 2);

  /// <summary>
  /// Result of emitting code.
  /// </summary>
  public record EmitResult(
    string SourceCode,
    string FileName);

  /// <summary>
  /// Emits a complete source file with all routes.
  /// </summary>
  public static EmitResult EmitSourceFile(
    IEnumerable<RouteDefinition> routes,
    EmitOptions? options = null)
  {
    options ??= new EmitOptions();
    StringBuilder sb = new();

    // File header
    sb.AppendLine("// <auto-generated/>");
    sb.AppendLine("// This code was generated by TimeWarp.Nuru source generator.");
    sb.AppendLine("// Do not modify this file directly.");
    sb.AppendLine();

    // Usings
    sb.AppendLine("using System;");
    sb.AppendLine("using System.Collections.Generic;");
    sb.AppendLine();

    // Namespace
    sb.AppendLine($"namespace {options.Namespace}");
    sb.AppendLine("{");

    // Include runtime types if requested
    if (options.IncludeRuntimeTypes)
    {
      EmitRuntimeTypes(sb, options.IndentSpaces);
      sb.AppendLine();
    }

    // Main generated class
    string indent = new(' ', options.IndentSpaces);
    sb.AppendLine($"{indent}internal static class {options.ClassName}");
    sb.AppendLine($"{indent}{{");

    // Emit each route as a static field
    int routeIndex = 0;
    List<string> routeFieldNames = [];

    foreach (RouteDefinition route in routes)
    {
      string fieldName = $"Route_{routeIndex}";
      routeFieldNames.Add(fieldName);
      EmitRouteField(sb, route, fieldName, options.IndentSpaces * 2);
      sb.AppendLine();
      routeIndex++;
    }

    // Emit the All array
    string indent2 = new(' ', options.IndentSpaces * 2);
    sb.AppendLine($"{indent2}/// <summary>");
    sb.AppendLine($"{indent2}/// All compiled routes, ready for matching.");
    sb.AppendLine($"{indent2}/// </summary>");
    sb.AppendLine($"{indent2}internal static readonly CompiledRoute[] All = new[]");
    sb.AppendLine($"{indent2}{{");

    string indent3 = new(' ', options.IndentSpaces * 3);
    for (int i = 0; i < routeFieldNames.Count; i++)
    {
      string comma = i < routeFieldNames.Count - 1 ? "," : "";
      sb.AppendLine($"{indent3}{routeFieldNames[i]}{comma}");
    }

    sb.AppendLine($"{indent2}}};");

    sb.AppendLine($"{indent}}}");
    sb.AppendLine("}");

    return new EmitResult(
      SourceCode: sb.ToString(),
      FileName: $"{options.ClassName}.g.cs");
  }

  /// <summary>
  /// Emits a single route as a static field.
  /// </summary>
  private static void EmitRouteField(
    StringBuilder sb,
    RouteDefinition route,
    string fieldName,
    int indentSpaces)
  {
    string indent = new(' ', indentSpaces);
    string indent2 = new(' ', indentSpaces + 2);
    string indent3 = new(' ', indentSpaces + 4);

    sb.AppendLine($"{indent}/// <summary>");
    sb.AppendLine($"{indent}/// Route: {EscapeXmlComment(route.OriginalPattern)}");
    if (route.Description is not null)
    {
      sb.AppendLine($"{indent}/// {EscapeXmlComment(route.Description)}");
    }
    sb.AppendLine($"{indent}/// </summary>");

    sb.AppendLine($"{indent}private static readonly CompiledRoute {fieldName} = new CompiledRoute");
    sb.AppendLine($"{indent}(");

    // Pattern
    sb.AppendLine($"{indent2}pattern: \"{EscapeString(route.OriginalPattern)}\",");

    // Segment matchers
    sb.AppendLine($"{indent2}segmentMatchers: new ISegmentMatcher[]");
    sb.AppendLine($"{indent2}{{");
    EmitSegmentMatchers(sb, route.Segments, indentSpaces + 4);
    sb.AppendLine($"{indent2}}},");

    // Parameter extractors
    sb.AppendLine($"{indent2}parameterExtractors: new ParameterExtractor[]");
    sb.AppendLine($"{indent2}{{");
    EmitParameterExtractors(sb, route.Segments, indentSpaces + 4);
    sb.AppendLine($"{indent2}}},");

    // Invoker
    sb.AppendLine($"{indent2}invoker: (Dictionary<string, object> parameters) =>");
    sb.AppendLine($"{indent2}{{");
    EmitInvoker(sb, route, indentSpaces + 4);
    sb.AppendLine($"{indent2}}}");

    sb.AppendLine($"{indent});");
  }

  /// <summary>
  /// Emits segment matchers for a route.
  /// </summary>
  private static void EmitSegmentMatchers(
    StringBuilder sb,
    IEnumerable<SegmentDefinition> segments,
    int indentSpaces)
  {
    string indent = new(' ', indentSpaces);

    foreach (SegmentDefinition segment in segments)
    {
      switch (segment)
      {
        case LiteralDefinition literal:
          sb.AppendLine($"{indent}new LiteralMatcher({literal.Position}, \"{EscapeString(literal.Value)}\"),");
          break;

        case ParameterDefinition param:
          string matcherType = param.TypeConstraint switch
          {
            "int" => "IntParameterMatcher",
            "long" => "LongParameterMatcher",
            "bool" => "BoolParameterMatcher",
            "Guid" or "guid" => "GuidParameterMatcher",
            _ => "StringParameterMatcher"
          };
          sb.AppendLine($"{indent}new {matcherType}({param.Position}, \"{EscapeString(param.Name)}\"),");
          break;

        case OptionDefinition option:
          // Options are handled differently - they're not positional
          // For now, skip them in the matcher array
          break;
      }
    }
  }

  /// <summary>
  /// Emits parameter extractors for a route.
  /// </summary>
  private static void EmitParameterExtractors(
    StringBuilder sb,
    IEnumerable<SegmentDefinition> segments,
    int indentSpaces)
  {
    string indent = new(' ', indentSpaces);

    foreach (SegmentDefinition segment in segments)
    {
      if (segment is ParameterDefinition param)
      {
        string converterMethod = param.TypeConstraint switch
        {
          "int" => "TypeConverter.ToInt32",
          "long" => "TypeConverter.ToInt64",
          "bool" => "TypeConverter.ToBoolean",
          "Guid" or "guid" => "TypeConverter.ToGuid",
          "double" => "TypeConverter.ToDouble",
          "decimal" => "TypeConverter.ToDecimal",
          _ => "TypeConverter.ToString"
        };
        sb.AppendLine($"{indent}new ParameterExtractor({param.Position}, \"{EscapeString(param.Name)}\", {converterMethod}),");
      }
    }
  }

  /// <summary>
  /// Emits the invoker delegate body for a route.
  /// </summary>
  private static void EmitInvoker(
    StringBuilder sb,
    RouteDefinition route,
    int indentSpaces)
  {
    string indent = new(' ', indentSpaces);

    // Extract parameters from dictionary
    foreach (ParameterBinding binding in route.Handler.Parameters)
    {
      if (binding.Source == BindingSource.Parameter ||
          binding.Source == BindingSource.Option ||
          binding.Source == BindingSource.Flag)
      {
        string typeCast = GetTypeCast(binding.ParameterTypeName);
        sb.AppendLine($"{indent}{binding.ShortTypeName} {binding.ParameterName} = {typeCast}parameters[\"{binding.SourceName}\"];");
      }
    }

    // Call the handler
    // For now, emit a placeholder - the actual delegate reference will come from elsewhere
    if (route.Handler.HandlerKind == HandlerKind.Delegate)
    {
      // Build parameter list
      List<string> paramNames = route.Handler.Parameters
        .Where(p => p.Source != BindingSource.Service && p.Source != BindingSource.CancellationToken)
        .Select(p => p.ParameterName)
        .ToList();

      string paramList = string.Join(", ", paramNames);

      if (route.Handler.ReturnType.IsVoid)
      {
        sb.AppendLine($"{indent}// TODO: Call delegate handler");
        sb.AppendLine($"{indent}// handler({paramList});");
        sb.AppendLine($"{indent}return null;");
      }
      else
      {
        sb.AppendLine($"{indent}// TODO: Call delegate handler and return result");
        sb.AppendLine($"{indent}// return handler({paramList});");
        sb.AppendLine($"{indent}return null; // Placeholder");
      }
    }
    else if (route.Handler.HandlerKind == HandlerKind.Mediator)
    {
      sb.AppendLine($"{indent}// TODO: Create request and send via mediator");
      sb.AppendLine($"{indent}// var request = new {route.Handler.FullTypeName}();");
      sb.AppendLine($"{indent}// return await mediator.Send(request);");
      sb.AppendLine($"{indent}return null; // Placeholder");
    }
  }

  /// <summary>
  /// Gets the type cast expression for a parameter type.
  /// </summary>
  private static string GetTypeCast(string typeName)
  {
    // Strip global:: prefix for cleaner output
    string shortType = typeName.StartsWith("global::", StringComparison.Ordinal)
      ? typeName[8..]
      : typeName;

    // Use simpler cast syntax for primitives
    return shortType switch
    {
      "System.Int32" => "(int)",
      "System.Int64" => "(long)",
      "System.String" => "(string)",
      "System.Boolean" => "(bool)",
      "System.Double" => "(double)",
      "System.Decimal" => "(decimal)",
      "System.Guid" => "(Guid)",
      _ => $"({shortType})"
    };
  }

  /// <summary>
  /// Emits the runtime types needed for the generated code.
  /// </summary>
  private static void EmitRuntimeTypes(StringBuilder sb, int baseIndent)
  {
    string indent = new(' ', baseIndent);
    string indent2 = new(' ', baseIndent + 2);
    string indent3 = new(' ', baseIndent + 4);

    // CompiledRoute
    sb.AppendLine($"{indent}/// <summary>");
    sb.AppendLine($"{indent}/// A compiled route ready for runtime matching and execution.");
    sb.AppendLine($"{indent}/// </summary>");
    sb.AppendLine($"{indent}internal sealed class CompiledRoute");
    sb.AppendLine($"{indent}{{");
    sb.AppendLine($"{indent2}public string Pattern {{ get; }}");
    sb.AppendLine($"{indent2}public ISegmentMatcher[] SegmentMatchers {{ get; }}");
    sb.AppendLine($"{indent2}public ParameterExtractor[] ParameterExtractors {{ get; }}");
    sb.AppendLine($"{indent2}public Func<Dictionary<string, object>, object?> Invoker {{ get; }}");
    sb.AppendLine();
    sb.AppendLine($"{indent2}public CompiledRoute(");
    sb.AppendLine($"{indent3}string pattern,");
    sb.AppendLine($"{indent3}ISegmentMatcher[] segmentMatchers,");
    sb.AppendLine($"{indent3}ParameterExtractor[] parameterExtractors,");
    sb.AppendLine($"{indent3}Func<Dictionary<string, object>, object?> invoker)");
    sb.AppendLine($"{indent2}{{");
    sb.AppendLine($"{indent3}Pattern = pattern;");
    sb.AppendLine($"{indent3}SegmentMatchers = segmentMatchers;");
    sb.AppendLine($"{indent3}ParameterExtractors = parameterExtractors;");
    sb.AppendLine($"{indent3}Invoker = invoker;");
    sb.AppendLine($"{indent2}}}");
    sb.AppendLine($"{indent}}}");
    sb.AppendLine();

    // ISegmentMatcher interface
    sb.AppendLine($"{indent}internal interface ISegmentMatcher");
    sb.AppendLine($"{indent}{{");
    sb.AppendLine($"{indent2}int Position {{ get; }}");
    sb.AppendLine($"{indent2}string Description {{ get; }}");
    sb.AppendLine($"{indent2}bool Matches(string value);");
    sb.AppendLine($"{indent}}}");
    sb.AppendLine();

    // LiteralMatcher
    sb.AppendLine($"{indent}internal sealed class LiteralMatcher : ISegmentMatcher");
    sb.AppendLine($"{indent}{{");
    sb.AppendLine($"{indent2}public int Position {{ get; }}");
    sb.AppendLine($"{indent2}public string ExpectedValue {{ get; }}");
    sb.AppendLine($"{indent2}public string Description => $\"literal '{{ExpectedValue}}'\";");
    sb.AppendLine();
    sb.AppendLine($"{indent2}public LiteralMatcher(int position, string expectedValue)");
    sb.AppendLine($"{indent2}{{");
    sb.AppendLine($"{indent3}Position = position;");
    sb.AppendLine($"{indent3}ExpectedValue = expectedValue;");
    sb.AppendLine($"{indent2}}}");
    sb.AppendLine();
    sb.AppendLine($"{indent2}public bool Matches(string value) =>");
    sb.AppendLine($"{indent3}string.Equals(value, ExpectedValue, StringComparison.OrdinalIgnoreCase);");
    sb.AppendLine($"{indent}}}");
    sb.AppendLine();

    // StringParameterMatcher
    sb.AppendLine($"{indent}internal sealed class StringParameterMatcher : ISegmentMatcher");
    sb.AppendLine($"{indent}{{");
    sb.AppendLine($"{indent2}public int Position {{ get; }}");
    sb.AppendLine($"{indent2}public string Name {{ get; }}");
    sb.AppendLine($"{indent2}public string Description => $\"parameter '{{Name}}' (string)\";");
    sb.AppendLine();
    sb.AppendLine($"{indent2}public StringParameterMatcher(int position, string name)");
    sb.AppendLine($"{indent2}{{");
    sb.AppendLine($"{indent3}Position = position;");
    sb.AppendLine($"{indent3}Name = name;");
    sb.AppendLine($"{indent2}}}");
    sb.AppendLine();
    sb.AppendLine($"{indent2}public bool Matches(string value) => !string.IsNullOrEmpty(value);");
    sb.AppendLine($"{indent}}}");
    sb.AppendLine();

    // IntParameterMatcher
    sb.AppendLine($"{indent}internal sealed class IntParameterMatcher : ISegmentMatcher");
    sb.AppendLine($"{indent}{{");
    sb.AppendLine($"{indent2}public int Position {{ get; }}");
    sb.AppendLine($"{indent2}public string Name {{ get; }}");
    sb.AppendLine($"{indent2}public string Description => $\"parameter '{{Name}}' (int)\";");
    sb.AppendLine();
    sb.AppendLine($"{indent2}public IntParameterMatcher(int position, string name)");
    sb.AppendLine($"{indent2}{{");
    sb.AppendLine($"{indent3}Position = position;");
    sb.AppendLine($"{indent3}Name = name;");
    sb.AppendLine($"{indent2}}}");
    sb.AppendLine();
    sb.AppendLine($"{indent2}public bool Matches(string value) => int.TryParse(value, out _);");
    sb.AppendLine($"{indent}}}");
    sb.AppendLine();

    // ParameterExtractor
    sb.AppendLine($"{indent}internal sealed class ParameterExtractor");
    sb.AppendLine($"{indent}{{");
    sb.AppendLine($"{indent2}public int Position {{ get; }}");
    sb.AppendLine($"{indent2}public string Name {{ get; }}");
    sb.AppendLine($"{indent2}public Func<string, object?> Convert {{ get; }}");
    sb.AppendLine();
    sb.AppendLine($"{indent2}public ParameterExtractor(int position, string name, Func<string, object?> convert)");
    sb.AppendLine($"{indent2}{{");
    sb.AppendLine($"{indent3}Position = position;");
    sb.AppendLine($"{indent3}Name = name;");
    sb.AppendLine($"{indent3}Convert = convert;");
    sb.AppendLine($"{indent2}}}");
    sb.AppendLine($"{indent}}}");
    sb.AppendLine();

    // TypeConverter
    sb.AppendLine($"{indent}internal static class TypeConverter");
    sb.AppendLine($"{indent}{{");
    sb.AppendLine($"{indent2}public static object? ToInt32(string value) =>");
    sb.AppendLine($"{indent3}int.TryParse(value, out int result) ? result : null;");
    sb.AppendLine();
    sb.AppendLine($"{indent2}public static object? ToInt64(string value) =>");
    sb.AppendLine($"{indent3}long.TryParse(value, out long result) ? result : null;");
    sb.AppendLine();
    sb.AppendLine($"{indent2}public static object? ToBoolean(string value) =>");
    sb.AppendLine($"{indent3}bool.TryParse(value, out bool result) ? result : null;");
    sb.AppendLine();
    sb.AppendLine($"{indent2}public static object? ToDouble(string value) =>");
    sb.AppendLine($"{indent3}double.TryParse(value, out double result) ? result : null;");
    sb.AppendLine();
    sb.AppendLine($"{indent2}public static object? ToDecimal(string value) =>");
    sb.AppendLine($"{indent3}decimal.TryParse(value, out decimal result) ? result : null;");
    sb.AppendLine();
    sb.AppendLine($"{indent2}public static object? ToGuid(string value) =>");
    sb.AppendLine($"{indent3}Guid.TryParse(value, out Guid result) ? result : null;");
    sb.AppendLine();
    sb.AppendLine($"{indent2}public static object? ToString(string value) => value;");
    sb.AppendLine($"{indent}}}");
    sb.AppendLine();

    // Router
    sb.AppendLine($"{indent}/// <summary>");
    sb.AppendLine($"{indent}/// Routes command-line args to the appropriate handler.");
    sb.AppendLine($"{indent}/// </summary>");
    sb.AppendLine($"{indent}internal sealed class Router");
    sb.AppendLine($"{indent}{{");
    sb.AppendLine($"{indent2}private readonly CompiledRoute[] _routes;");
    sb.AppendLine();
    sb.AppendLine($"{indent2}public Router(CompiledRoute[] routes)");
    sb.AppendLine($"{indent2}{{");
    sb.AppendLine($"{indent3}_routes = routes;");
    sb.AppendLine($"{indent2}}}");
    sb.AppendLine();
    sb.AppendLine($"{indent2}public MatchResult Match(string[] args)");
    sb.AppendLine($"{indent2}{{");
    sb.AppendLine($"{indent3}foreach (CompiledRoute route in _routes)");
    sb.AppendLine($"{indent3}{{");
    sb.AppendLine($"{indent3}  MatchAttempt attempt = TryMatch(route, args);");
    sb.AppendLine($"{indent3}  if (attempt.IsSuccess)");
    sb.AppendLine($"{indent3}  {{");
    sb.AppendLine($"{indent3}    return MatchResult.Matched(route, attempt.Parameters!);");
    sb.AppendLine($"{indent3}  }}");
    sb.AppendLine($"{indent3}}}");
    sb.AppendLine($"{indent3}return MatchResult.NoMatch(\"No routes matched the input\");");
    sb.AppendLine($"{indent2}}}");
    sb.AppendLine();
    sb.AppendLine($"{indent2}private static MatchAttempt TryMatch(CompiledRoute route, string[] args)");
    sb.AppendLine($"{indent2}{{");
    sb.AppendLine($"{indent3}// Check segment count");
    sb.AppendLine($"{indent3}if (args.Length != route.SegmentMatchers.Length)");
    sb.AppendLine($"{indent3}{{");
    sb.AppendLine($"{indent3}  return MatchAttempt.Failed();");
    sb.AppendLine($"{indent3}}}");
    sb.AppendLine();
    sb.AppendLine($"{indent3}// Check each segment matches");
    sb.AppendLine($"{indent3}for (int i = 0; i < route.SegmentMatchers.Length; i++)");
    sb.AppendLine($"{indent3}{{");
    sb.AppendLine($"{indent3}  if (!route.SegmentMatchers[i].Matches(args[i]))");
    sb.AppendLine($"{indent3}  {{");
    sb.AppendLine($"{indent3}    return MatchAttempt.Failed();");
    sb.AppendLine($"{indent3}  }}");
    sb.AppendLine($"{indent3}}}");
    sb.AppendLine();
    sb.AppendLine($"{indent3}// Extract parameters");
    sb.AppendLine($"{indent3}Dictionary<string, object> parameters = new();");
    sb.AppendLine($"{indent3}foreach (ParameterExtractor extractor in route.ParameterExtractors)");
    sb.AppendLine($"{indent3}{{");
    sb.AppendLine($"{indent3}  string rawValue = args[extractor.Position];");
    sb.AppendLine($"{indent3}  object? converted = extractor.Convert(rawValue);");
    sb.AppendLine($"{indent3}  if (converted is null)");
    sb.AppendLine($"{indent3}  {{");
    sb.AppendLine($"{indent3}    return MatchAttempt.Failed();");
    sb.AppendLine($"{indent3}  }}");
    sb.AppendLine($"{indent3}  parameters[extractor.Name] = converted;");
    sb.AppendLine($"{indent3}}}");
    sb.AppendLine();
    sb.AppendLine($"{indent3}return MatchAttempt.Succeeded(parameters);");
    sb.AppendLine($"{indent2}}}");
    sb.AppendLine($"{indent}}}");
    sb.AppendLine();

    // MatchAttempt (internal helper)
    sb.AppendLine($"{indent}internal readonly struct MatchAttempt");
    sb.AppendLine($"{indent}{{");
    sb.AppendLine($"{indent2}public bool IsSuccess {{ get; }}");
    sb.AppendLine($"{indent2}public Dictionary<string, object>? Parameters {{ get; }}");
    sb.AppendLine();
    sb.AppendLine($"{indent2}private MatchAttempt(bool isSuccess, Dictionary<string, object>? parameters)");
    sb.AppendLine($"{indent2}{{");
    sb.AppendLine($"{indent3}IsSuccess = isSuccess;");
    sb.AppendLine($"{indent3}Parameters = parameters;");
    sb.AppendLine($"{indent2}}}");
    sb.AppendLine();
    sb.AppendLine($"{indent2}public static MatchAttempt Failed() => new(false, null);");
    sb.AppendLine($"{indent2}public static MatchAttempt Succeeded(Dictionary<string, object> parameters) => new(true, parameters);");
    sb.AppendLine($"{indent}}}");
    sb.AppendLine();

    // MatchResult
    sb.AppendLine($"{indent}/// <summary>");
    sb.AppendLine($"{indent}/// Result of routing, with ability to execute the matched handler.");
    sb.AppendLine($"{indent}/// </summary>");
    sb.AppendLine($"{indent}internal sealed class MatchResult");
    sb.AppendLine($"{indent}{{");
    sb.AppendLine($"{indent2}public bool IsMatch {{ get; }}");
    sb.AppendLine($"{indent2}public string? FailureReason {{ get; }}");
    sb.AppendLine($"{indent2}private readonly CompiledRoute? _route;");
    sb.AppendLine($"{indent2}private readonly Dictionary<string, object>? _parameters;");
    sb.AppendLine();
    sb.AppendLine($"{indent2}private MatchResult(bool isMatch, string? failureReason, CompiledRoute? route, Dictionary<string, object>? parameters)");
    sb.AppendLine($"{indent2}{{");
    sb.AppendLine($"{indent3}IsMatch = isMatch;");
    sb.AppendLine($"{indent3}FailureReason = failureReason;");
    sb.AppendLine($"{indent3}_route = route;");
    sb.AppendLine($"{indent3}_parameters = parameters;");
    sb.AppendLine($"{indent2}}}");
    sb.AppendLine();
    sb.AppendLine($"{indent2}public static MatchResult NoMatch(string reason) => new(false, reason, null, null);");
    sb.AppendLine($"{indent2}public static MatchResult Matched(CompiledRoute route, Dictionary<string, object> parameters) => new(true, null, route, parameters);");
    sb.AppendLine();
    sb.AppendLine($"{indent2}public object? Execute()");
    sb.AppendLine($"{indent2}{{");
    sb.AppendLine($"{indent3}if (!IsMatch || _route is null || _parameters is null)");
    sb.AppendLine($"{indent3}{{");
    sb.AppendLine($"{indent3}  throw new InvalidOperationException(\"Cannot execute a non-matched result\");");
    sb.AppendLine($"{indent3}}}");
    sb.AppendLine($"{indent3}return _route.Invoker(_parameters);");
    sb.AppendLine($"{indent2}}}");
    sb.AppendLine();
    sb.AppendLine($"{indent2}public string? MatchedPattern => _route?.Pattern;");
    sb.AppendLine($"{indent2}public Dictionary<string, object>? ExtractedParameters => _parameters;");
    sb.AppendLine($"{indent}}}");
  }

  /// <summary>
  /// Escapes a string for use in C# source code.
  /// </summary>
  private static string EscapeString(string value)
  {
    return value
      .Replace("\\", "\\\\")
      .Replace("\"", "\\\"")
      .Replace("\n", "\\n")
      .Replace("\r", "\\r")
      .Replace("\t", "\\t");
  }

  /// <summary>
  /// Escapes text for use in XML comments.
  /// </summary>
  private static string EscapeXmlComment(string value)
  {
    return value
      .Replace("&", "&amp;")
      .Replace("<", "&lt;")
      .Replace(">", "&gt;");
  }
}
