// Main emitter that generates the RunAsync interceptor methods.
// This is the entry point for code emission, coordinating all other emitters.
//
// Key design: Each app instance gets its own interceptor method with isolated routes.
// This ensures route patterns don't leak between different NuruCoreApp instances.

namespace TimeWarp.Nuru.Generators;

using System.Text;

/// <summary>
/// Emits the complete generated interceptor source file.
/// This is the main entry point for the emission phase.
/// </summary>
internal static class InterceptorEmitter
{
  /// <summary>
  /// Generates the complete source code for the interceptor.
  /// </summary>
  /// <param name="model">The generator model containing all apps and routes.</param>
  /// <returns>The generated C# source code.</returns>
  public static string Emit(GeneratorModel model)
  {
    StringBuilder sb = new();

    EmitHeader(sb);
    EmitInterceptsLocationAttribute(sb);
    EmitNamespaceAndUsings(sb, model);
    EmitClassStart(sb);

    // Emit shared infrastructure (command classes, service fields, behaviors)
    EmitCommandClasses(sb, model);
    EmitServiceFields(sb, model.AllServices);
    BehaviorEmitter.EmitBehaviorFields(sb, [.. model.AllBehaviors], [.. model.AllServices]);

    // Emit per-app interceptor methods
    for (int appIndex = 0; appIndex < model.Apps.Length; appIndex++)
    {
      AppModel app = model.Apps[appIndex];
      EmitAppInterceptorMethod(sb, app, appIndex, model);
    }

    EmitClassEnd(sb, model);

    return sb.ToString();
  }

  /// <summary>
  /// Emits a single interceptor method for one app.
  /// Each app gets its own method with its own [InterceptsLocation] attributes and routes.
  /// </summary>
  private static void EmitAppInterceptorMethod(StringBuilder sb, AppModel app, int appIndex, GeneratorModel model)
  {
    // Emit [InterceptsLocation] attributes for this app's RunAsync calls
    foreach (InterceptSiteModel site in app.InterceptSites)
    {
      sb.AppendLine($"  {site.GetAttributeSyntax()}");
    }

    // Method signature - use index suffix for uniqueness when multiple apps
    string methodSuffix = model.Apps.Length > 1 ? $"_{appIndex}" : "";
    sb.AppendLine($"  public static async Task<int> RunAsync_Intercepted{methodSuffix}");
    sb.AppendLine("  (");
    sb.AppendLine("    this NuruCoreApp app,");
    sb.AppendLine("    string[] args");
    sb.AppendLine("  )");
    sb.AppendLine("  {");

    // Method body with this app's routes only
    EmitMethodBody(sb, app, model);

    sb.AppendLine("  }");
    sb.AppendLine();
  }

  /// <summary>
  /// Emits the InterceptsLocationAttribute definition.
  /// In .NET 10 / C# 14, interceptors use the new versioned constructor:
  /// InterceptsLocationAttribute(int version, string data)
  /// We use 'file' scope so it doesn't conflict with other generators that may define it.
  /// </summary>
  private static void EmitInterceptsLocationAttribute(StringBuilder sb)
  {
    sb.AppendLine("namespace System.Runtime.CompilerServices");
    sb.AppendLine("{");
    sb.AppendLine("  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]");
    sb.AppendLine("  file sealed class InterceptsLocationAttribute : global::System.Attribute");
    sb.AppendLine("  {");
    sb.AppendLine("    public InterceptsLocationAttribute(int version, string data)");
    sb.AppendLine("    {");
    sb.AppendLine("      Version = version;");
    sb.AppendLine("      Data = data;");
    sb.AppendLine("    }");
    sb.AppendLine();
    sb.AppendLine("    public int Version { get; }");
    sb.AppendLine("    public string Data { get; }");
    sb.AppendLine("  }");
    sb.AppendLine("}");
    sb.AppendLine();
  }

  /// <summary>
  /// Emits the auto-generated header comment, pragma warning disable, and nullable enable.
  /// </summary>
  private static void EmitHeader(StringBuilder sb)
  {
    sb.AppendLine("// <auto-generated/>");
    sb.AppendLine("// This code was generated by TimeWarp.Nuru V2 source generator.");
    sb.AppendLine("// Do not modify this file directly.");
    sb.AppendLine("#pragma warning disable");
    sb.AppendLine("#nullable enable");
    sb.AppendLine();
  }

  /// <summary>
  /// Emits the namespace declaration and using statements.
  /// Uses block-scoped namespace to be compatible with the InterceptsLocationAttribute
  /// which is in a separate namespace block in the same file.
  /// </summary>
  private static void EmitNamespaceAndUsings(StringBuilder sb, GeneratorModel model)
  {
    sb.AppendLine("namespace TimeWarp.Nuru.Generated");
    sb.AppendLine("{");
    sb.AppendLine();

    // Default usings required by generated code
    sb.AppendLine("using global::System.Linq;");
    sb.AppendLine("using global::System.Net.Http;");
    sb.AppendLine("using global::System.Reflection;");
    sb.AppendLine("using global::System.Runtime.CompilerServices;");
    sb.AppendLine("using global::System.Text.Json;");
    sb.AppendLine("using global::System.Text.Json.Serialization;");
    sb.AppendLine("using global::System.Text.RegularExpressions;");
    sb.AppendLine("using global::System.Threading.Tasks;");
    sb.AppendLine("using global::Microsoft.Extensions.Configuration;");
    sb.AppendLine("using global::Microsoft.Extensions.Configuration.Json;");
    sb.AppendLine("using global::Microsoft.Extensions.Configuration.EnvironmentVariables;");
    sb.AppendLine("#if DEBUG");
    sb.AppendLine("using global::Microsoft.Extensions.Configuration.UserSecrets;");
    sb.AppendLine("#endif");
    sb.AppendLine("using global::TimeWarp.Nuru;");
    sb.AppendLine("using global::TimeWarp.Terminal;");

    // User-defined usings from source file
    if (model.UserUsings.Length > 0)
    {
      sb.AppendLine();
      sb.AppendLine("// User-defined usings");
      foreach (string userUsing in model.UserUsings)
      {
        sb.AppendLine(userUsing);
      }
    }

    sb.AppendLine();
  }

  /// <summary>
  /// Emits the file-scoped static class declaration.
  /// </summary>
  private static void EmitClassStart(StringBuilder sb)
  {
    sb.AppendLine("file static class GeneratedInterceptor");
    sb.AppendLine("{");
  }

  /// <summary>
  /// Emits generated command classes for delegate routes.
  /// These provide command instances for behaviors.
  /// </summary>
  private static void EmitCommandClasses(StringBuilder sb, GeneratorModel model)
  {
    // Emit command classes for all routes across all apps
    CommandClassEmitter.EmitCommandClasses(sb, model.AllRoutes);
  }

  /// <summary>
  /// Emits static Lazy fields for Singleton and Scoped services.
  /// These provide thread-safe lazy initialization for cached service instances.
  /// </summary>
  private static void EmitServiceFields(StringBuilder sb, IEnumerable<ServiceDefinition> services)
  {
    // Only emit fields for Singleton and Scoped services (not Transient)
    // Materialize to array to avoid multiple enumeration
    ServiceDefinition[] cachedServices =
    [
      .. services
        .Where(s => s.Lifetime is ServiceLifetime.Singleton or ServiceLifetime.Scoped)
        .DistinctBy(s => s.ImplementationTypeName) // Avoid duplicates if same impl registered multiple times
    ];

    if (cachedServices.Length == 0)
      return;

    sb.AppendLine("  // Static service fields (thread-safe lazy initialization)");

    foreach (ServiceDefinition service in cachedServices)
    {
      string fieldName = GetServiceFieldName(service.ImplementationTypeName);
      sb.AppendLine(
        $"  private static readonly global::System.Lazy<{service.ImplementationTypeName}> {fieldName} = new(() => new {service.ImplementationTypeName}());");
    }

    sb.AppendLine();
  }

  /// <summary>
  /// Gets the static field name for a service implementation type.
  /// </summary>
  /// <param name="implementationTypeName">Fully qualified implementation type name.</param>
  /// <returns>Field name like "__svc_MyApp_Services_Greeter".</returns>
  internal static string GetServiceFieldName(string implementationTypeName)
  {
    string name = implementationTypeName;

    // Remove global:: prefix
    if (name.StartsWith("global::", StringComparison.Ordinal))
      name = name[8..];

    // Replace dots with underscores for valid C# identifier
    return "__svc_" + name.Replace(".", "_", StringComparison.Ordinal);
  }

  /// <summary>
  /// Emits the complete method body including all route matching logic.
  /// </summary>
  private static void EmitMethodBody(StringBuilder sb, AppModel app, GeneratorModel model)
  {
    // Configuration setup (if AddConfiguration was called)
    if (app.HasConfiguration)
    {
      ConfigurationEmitter.Emit(sb);
    }

    // Filter out configuration override args before route matching
    // Config overrides follow pattern: --Section:Key=value (starts with -- and contains :)
    // This allows AddCommandLine(args) to process them while route matching ignores them
    EmitConfigArgFiltering(sb);

    // Built-in flags: --help, --version, --capabilities
    EmitBuiltInFlags(sb, app);

    // Route matching - emit this app's routes in specificity order (highest first)
    // Also include attributed routes which are shared across all apps
    IEnumerable<RouteDefinition> allRoutes = app.RoutesBySpecificity.Concat(model.AttributedRoutes);

    int routeIndex = 0;
    foreach (RouteDefinition route in allRoutes.OrderByDescending(r => r.ComputedSpecificity))
    {
      RouteMatcherEmitter.Emit(sb, route, routeIndex, app.Services, app.Behaviors, app.CustomConverters);
      routeIndex++;
    }

    // No match fallback
    EmitNoMatch(sb);
  }

  /// <summary>
  /// Emits handling for built-in flags (--help, --version, --capabilities).
  /// </summary>
  private static void EmitBuiltInFlags(StringBuilder sb, AppModel app)
  {
    // --help flag
    if (app.HasHelp)
    {
      sb.AppendLine("    // Built-in: --help");
      sb.AppendLine("    if (routeArgs is [\"--help\" or \"-h\"])");
      sb.AppendLine("    {");
      sb.AppendLine("      PrintHelp(app.Terminal);");
      sb.AppendLine("      return 0;");
      sb.AppendLine("    }");
      sb.AppendLine();
    }

    // --version flag (always available)
    sb.AppendLine("    // Built-in: --version");
    sb.AppendLine("    if (routeArgs is [\"--version\"])");
    sb.AppendLine("    {");
    sb.AppendLine("      PrintVersion(app.Terminal);");
    sb.AppendLine("      return 0;");
    sb.AppendLine("    }");
    sb.AppendLine();

    // --capabilities flag (always available for AI tools)
    sb.AppendLine("    // Built-in: --capabilities (for AI tools)");
    sb.AppendLine("    if (routeArgs is [\"--capabilities\"])");
    sb.AppendLine("    {");
    sb.AppendLine("      PrintCapabilities(app.Terminal);");
    sb.AppendLine("      return 0;");
    sb.AppendLine("    }");
    sb.AppendLine();

    // --check-updates flag (opt-in via AddCheckUpdatesRoute())
    if (app.HasCheckUpdatesRoute)
    {
      sb.AppendLine("    // Built-in: --check-updates (opt-in via AddCheckUpdatesRoute())");
      sb.AppendLine("    if (routeArgs is [\"--check-updates\"])");
      sb.AppendLine("    {");
      sb.AppendLine("      await CheckForUpdatesAsync(app.Terminal).ConfigureAwait(false);");
      sb.AppendLine("      return 0;");
      sb.AppendLine("    }");
      sb.AppendLine();
    }
  }

  /// <summary>
  /// Emits code to filter out configuration override args before route matching.
  /// Config overrides follow pattern: --Section:Key=value (starts with -- and contains :)
  /// This allows AddCommandLine(args) to process them while route matching ignores them.
  /// </summary>
  private static void EmitConfigArgFiltering(StringBuilder sb)
  {
    sb.AppendLine("    // Filter out configuration override args before route matching");
    sb.AppendLine("    // Config overrides follow pattern: --Section:Key=value (starts with -- and contains :)");
    sb.AppendLine("    // Original args are still passed to AddCommandLine() for configuration");
    sb.AppendLine("    string[] routeArgs = [.. args.Where(arg => !(arg.StartsWith(\"--\", global::System.StringComparison.Ordinal) && arg.Contains(':', global::System.StringComparison.Ordinal)))];");
    sb.AppendLine();
  }

  /// <summary>
  /// Emits the no-match fallback code.
  /// </summary>
  private static void EmitNoMatch(StringBuilder sb)
  {
    sb.AppendLine("    // No route matched");
    sb.AppendLine("    await app.Terminal.WriteErrorLineAsync(\"Unknown command. Use --help for usage.\").ConfigureAwait(false);");
    sb.AppendLine("    return 1;");
  }

  /// <summary>
  /// Emits the closing of the class and helper methods.
  /// </summary>
  private static void EmitClassEnd(StringBuilder sb, GeneratorModel model)
  {
    sb.AppendLine();

    // Create a combined AppModel for helper method emission
    // These helpers (PrintHelp, PrintVersion, etc.) need route info from all apps
    AppModel combinedForHelpers = CreateCombinedAppModelForHelpers(model);

    HelpEmitter.Emit(sb, combinedForHelpers);
    sb.AppendLine();
    VersionEmitter.Emit(sb, combinedForHelpers);
    sb.AppendLine();
    CapabilitiesEmitter.Emit(sb, combinedForHelpers);

    if (model.HasCheckUpdatesRoute)
    {
      sb.AppendLine();
      CheckUpdatesEmitter.Emit(sb, combinedForHelpers);
    }

    sb.AppendLine("}"); // Close class
    sb.AppendLine("}"); // Close namespace
  }

  /// <summary>
  /// Creates a combined AppModel for emitting helper methods.
  /// Helper methods (PrintHelp, PrintVersion, etc.) need aggregated data from all apps.
  /// </summary>
  private static AppModel CreateCombinedAppModelForHelpers(GeneratorModel model)
  {
    // Combine all routes for help output
    ImmutableArray<RouteDefinition> allRoutes = [.. model.AllRoutes];

    return new AppModel(
      VariableName: null,
      Name: model.Name,
      Description: model.Description,
      AiPrompt: model.AiPrompt,
      HasHelp: model.HasHelp,
      HelpOptions: model.HelpOptions,
      HasRepl: model.HasRepl,
      ReplOptions: model.ReplOptions,
      HasConfiguration: model.HasConfiguration,
      HasCheckUpdatesRoute: model.HasCheckUpdatesRoute,
      Routes: allRoutes,
      Behaviors: [.. model.AllBehaviors],
      Services: [.. model.AllServices],
      InterceptSites: [], // Not needed for helpers
      UserUsings: model.UserUsings,
      CustomConverters: [.. model.AllConverters],
      LoggingConfiguration: null); // Combined model doesn't use logging config
  }
}
