# V2 Source Generator Flow

## Executive Summary

The V2 source generator analyzes user code at compile time and emits generated code that replaces the runtime execution path. The user's fluent API code serves as a DSL for the generator - it's analyzed but not executed at runtime. This enables zero-cost `Build()` where all route registration happens at compile time.

## How Source Generators Work

Source generators are **additive only** - they can add new source files to the compilation but cannot modify or remove existing code.

This means:
- User's original code **will** be compiled
- User's lambdas **will** exist in IL
- User's fluent chains **will** be callable
- Generator adds **new** code alongside the original

## The V2 Flow

### Compile Time

```
User Source Code                    Source Generator
─────────────────                   ────────────────
                                    
builder.Map("add {x} {y}")          1. Syntax Provider detects Map()
  .WithHandler((x, y) => x + y)  ──►2. Extractor captures:
  .AsQuery()                           - Pattern: "add {x} {y}"
  .Done();                             - Lambda: (x, y) => x + y
                                       - MessageType: Query
                                    
                                    3. Parser builds RouteDefinition
                                    
                                    4. Emitter generates:
                                    ┌─────────────────────────────────┐
                                    │ // <auto-generated/>            │
                                    │ internal static class           │
                                    │   GeneratedEndpoints            │
                                    │ {                               │
                                    │   static Endpoint[] All = [     │
                                    │     new Endpoint {              │
                                    │       RoutePattern = "add...",  │
                                    │       CompiledRoute = ...,      │
                                    │       Handler = (x, y) => x + y │
                                    │     }                           │
                                    │   ];                            │
                                    │ }                               │
                                    └─────────────────────────────────┘
```

### Runtime

```
V1 Path (OLD - not used)              V2 Path (NEW - used)
────────────────────────              ────────────────────

app.Build()                           app.Build()
  │                                     │
  ▼                                     ▼
Execute fluent chain                  Return reference to
  │                                   GeneratedEndpoints.All
  ▼                                     │
Parse patterns at runtime               │ (no parsing)
  │                                     │
  ▼                                     │
Create CompiledRoutes                   │ (already compiled)
  │                                     │
  ▼                                     │
Sort by specificity                     │ (already sorted)
  │                                     │
  ▼                                     ▼
Register handlers                     Handlers already bound
  │                                     │
  ▼                                     ▼
Return NuruCoreApp                    Return NuruCoreApp
```

## Handler Emission Strategy

### The Question

When user writes:
```csharp
.WithHandler((int x, int y) => x + y)
```

How do we emit this in generated code?

### The Answer

**Emit the lambda body directly** in the generated code:

```csharp
// Generated
Handler = (int x, int y) => x + y
```

### Why This Works

1. **Generator has the syntax** - `FluentChainExtractor` captures `LambdaExpressionSyntax`

2. **We can emit it verbatim** - The lambda syntax can be written into generated code

3. **Duplication is acceptable**:
   - Original lambda compiles (generator is additive)
   - Generated lambda also compiles
   - Runtime uses generated path only
   - Original becomes dead code

4. **Linker handles cleanup**:
   - For trimmed/AOT builds, linker removes unreachable code
   - Original fluent chain is never called → removed
   - Only generated path remains in final binary

### Code Duplication Diagram

```
Compiled Assembly (before trimming)
┌─────────────────────────────────────────────────┐
│                                                 │
│  User Code (compiled but not called)            │
│  ┌───────────────────────────────────────────┐  │
│  │ .WithHandler((int x, int y) => x + y)     │  │
│  │            ↓                              │  │
│  │ Becomes: <>c.<Main>b__0_0 (compiler name) │  │
│  │ Status: DEAD CODE - never invoked         │  │
│  └───────────────────────────────────────────┘  │
│                                                 │
│  Generated Code (called at runtime)             │
│  ┌───────────────────────────────────────────┐  │
│  │ Handler = (int x, int y) => x + y         │  │
│  │            ↓                              │  │
│  │ Becomes: GeneratedEndpoints.<>c__0        │  │
│  │ Status: LIVE CODE - invoked at runtime    │  │
│  └───────────────────────────────────────────┘  │
│                                                 │
└─────────────────────────────────────────────────┘

After Linker/Trimmer
┌─────────────────────────────────────────────────┐
│                                                 │
│  Generated Code only                            │
│  ┌───────────────────────────────────────────┐  │
│  │ Handler = (int x, int y) => x + y         │  │
│  │ Status: LIVE CODE                         │  │
│  └───────────────────────────────────────────┘  │
│                                                 │
│  (User's original lambda removed as dead code)  │
│                                                 │
└─────────────────────────────────────────────────┘
```

## What the Generator Extracts

From `FluentChainExtractor`:

| Extracted            | Source                        | Used For                         |
| -------------------- | ----------------------------- | -------------------------------- |
| `Pattern`            | `Map("pattern")` argument       | Route matching                   |
| `Description`        | `.WithDescription("...")` arg   | Help text                        |
| `MessageType`        | `.AsQuery()`, `.AsCommand()`, etc. | Categorization                   |
| `Aliases`            | `.WithAlias("...")` args        | Alternative patterns             |
| `HandlerLambda`      | `.WithHandler(lambda)` arg      | **Emitted directly in generated code** |

From `DelegateAnalyzer`:

| Extracted        | Source                  | Used For           |
| ---------------- | ----------------------- | ------------------ |
| Parameters       | Lambda parameter list   | Parameter binding  |
| Return type      | Lambda return type      | Result handling    |
| IsAsync          | Returns Task/ValueTask? | Async invocation   |

## Implications for Tasks

### Task #243 (Emit pre-sorted Endpoint[])

- Emit `Endpoint[]` not just `CompiledRoute[]`
- Include `Handler` property with emitted lambda
- Include all endpoint metadata

### Task #248 (Zero-cost Build)

- `Build()` returns reference to `GeneratedEndpoints.All`
- No fluent chain execution at runtime
- Original user code becomes dead code

### Task #249 (Delete runtime infrastructure)

- Once V2 is proven, delete V1 fluent chain processing
- Keep fluent API as generator input DSL
- Remove runtime registration mechanisms

## Key Insight

The fluent API (`Map().WithHandler().Done()`) transforms from **runtime code** to **compile-time DSL**:

| Aspect   | V1 (Runtime)                 | V2 (Generated)                    |
| -------- | ---------------------------- | --------------------------------- |
| Purpose  | Execute at runtime to register routes | Analyzed at compile time |
| Lambda   | Stored in registry, invoked at runtime | Copied to generated code |
| Pattern  | Parsed at runtime            | Parsed at compile time            |
| Sorting  | Done in `Build()`            | Done in generator                 |
| Result   | `EndpointCollection`         | `GeneratedEndpoints.All` (static) |
