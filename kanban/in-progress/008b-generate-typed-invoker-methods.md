# Generate Typed Invoker Methods

## Description

Generate compile-time typed invoker methods that cast delegates and invoke without reflection. Each unique delegate signature gets a dedicated invoker method that performs type-safe invocation.

## Parent

008-implement-source-generators-for-reflection-free-routing

## Dependencies

- 008a-extract-delegate-signatures-from-map-calls

## Requirements

- Generate a static invoker method for each unique delegate signature
- Cast Delegate to the correct Action<>/Func<> type
- Cast object[] args to correct parameter types
- Handle return values correctly (void, value types, reference types)
- Use Scriban templates or string building for code generation
- Generate incrementally (only regenerate when signatures change)

## Checklist

### Implementation
- [x] ~~Create Scriban template for invoker methods~~ Used StringBuilder (simpler for this use case)
- [x] Generate Action<> invokers for void returns
- [x] Generate Func<> invokers for value returns
- [x] Generate async invokers for Task/Task<T> returns
- [x] Handle parameter casting with null checks
- [x] Generate unique method names per signature
- [x] Emit proper nullable annotations
- [x] Generate lookup dictionaries (SyncInvokers, AsyncInvokers)

### Generated Code Shape
```csharp
// <auto-generated/>
internal static class GeneratedRouteInvokers
{
    public static object? Invoke_Action_String(Delegate handler, object?[] args)
    {
        ((Action<string>)handler)((string)args[0]!);
        return null;
    }
    
    public static object? Invoke_Func_Int_Int_Int(Delegate handler, object?[] args)
    {
        return ((Func<int, int, int>)handler)((int)args[0]!, (int)args[1]!);
    }
    
    public static async Task<object?> InvokeAsync_Func_String_TaskInt(Delegate handler, object?[] args)
    {
        return await ((Func<string, Task<int>>)handler)((string)args[0]!);
    }
}
```

### Testing
- [x] Verify generated code compiles
- [x] Test invokers with various parameter combinations
- [x] Test async invokers with Task and Task<T>
- [x] Verify no reflection warnings in generated code

### Infrastructure
- [x] Fixed analyzer reference propagation in test-apps (analyzer refs don't flow transitively)
- [x] Created unit tests: `tests/timewarp-nuru-analyzers-tests/nuru-invoker-generator-01-basic.cs`

## Notes

Consider using Scriban like martinothamar/Mediator:
- `Implementation/resources/*.sbn-cs` - Template examples

Key considerations:
- Method naming must be deterministic and unique per signature
- Handle both sync and async delegates
- Ensure generated code is trimmer-friendly

## Implementation Details

### Files Created/Modified
- `source/timewarp-nuru-analyzers/analyzers/nuru-invoker-generator.cs` - Main source generator
- `tests/timewarp-nuru-analyzers-tests/nuru-invoker-generator-01-basic.cs` - Unit tests
- `tests/test-apps/Directory.Build.props` - Added direct analyzer reference

### Key Learnings
- Analyzer project references with `OutputItemType="Analyzer"` do NOT flow transitively
- When consuming as NuGet package, analyzer will be bundled correctly
- For local development/testing, need direct analyzer reference
- `ToDisplayString(FullyQualifiedFormat)` for `Nullable<int>` returns `int?` not `System.Nullable<int>`

### Generated Output Location
- `.generated/TimeWarp.Nuru.Analyzers/TimeWarp.Nuru.NuruInvokerGenerator/GeneratedRouteInvokers.g.cs`

## Status

**COMPLETE** - Ready to move to done once 008c (wire to DelegateExecutor) is started.
