namespace TimeWarp.Nuru;

/// <summary>
/// Source generator that creates route registration code for classes with [NuruRoute] attribute.
/// Generates RouteBuilder calls and ModuleInitializer registration code.
/// </summary>
[Generator]
public class NuruAttributedRouteGenerator : IIncrementalGenerator
{
  private const string NuruRouteAttributeName = "TimeWarp.Nuru.NuruRouteAttribute";
  private const string NuruRouteAliasAttributeName = "TimeWarp.Nuru.NuruRouteAliasAttribute";
  private const string NuruRouteGroupAttributeName = "TimeWarp.Nuru.NuruRouteGroupAttribute";
  private const string ParameterAttributeName = "TimeWarp.Nuru.ParameterAttribute";
  private const string OptionAttributeName = "TimeWarp.Nuru.OptionAttribute";
  private const string GroupOptionAttributeName = "TimeWarp.Nuru.GroupOptionAttribute";

  public void Initialize(IncrementalGeneratorInitializationContext context)
  {
    // Find all class declarations that might have [NuruRoute] attribute
    IncrementalValuesProvider<AttributedRouteInfo?> attributedRoutes = context.SyntaxProvider
      .CreateSyntaxProvider(
        predicate: static (node, _) => IsClassWithNuruRouteAttribute(node),
        transform: static (ctx, ct) => ExtractRouteInfoFromSyntax(ctx, ct))
      .Where(static info => info is not null);

    // Collect all routes
    IncrementalValueProvider<ImmutableArray<AttributedRouteInfo?>> collectedRoutes = attributedRoutes.Collect();

    // Generate source code
    context.RegisterSourceOutput(collectedRoutes, static (ctx, routes) =>
    {
      // Always generate a marker comment so we know the generator ran
      string header = "// <auto-generated/>\n// Generator ran. Routes found: " + routes.Length + "\n";

      if (routes.IsDefaultOrEmpty)
      {
        ctx.AddSource("GeneratedAttributedRoutes.g.cs", header + "// No routes found\n");
        return;
      }

      List<AttributedRouteInfo> validRoutes = [.. routes
        .Where(r => r is not null)
        .Cast<AttributedRouteInfo>()];

      if (validRoutes.Count == 0)
      {
        ctx.AddSource("GeneratedAttributedRoutes.g.cs", header + "// No valid routes\n");
        return;
      }

      string source = GenerateRegistrationCode(validRoutes);
      ctx.AddSource("GeneratedAttributedRoutes.g.cs", source);
    });
  }

  private static bool IsClassWithNuruRouteAttribute(Microsoft.CodeAnalysis.SyntaxNode node)
  {
    if (node is not ClassDeclarationSyntax classDecl)
      return false;

    // Check if class has any attribute that looks like NuruRoute
    foreach (AttributeListSyntax attrList in classDecl.AttributeLists)
    {
      foreach (AttributeSyntax attr in attrList.Attributes)
      {
        string name = attr.Name.ToString();
        if (name is "NuruRoute" or "NuruRouteAttribute" or "TimeWarp.Nuru.NuruRoute" or "TimeWarp.Nuru.NuruRouteAttribute")
          return true;
      }
    }

    return false;
  }

  private static AttributedRouteInfo? ExtractRouteInfoFromSyntax(GeneratorSyntaxContext ctx, CancellationToken ct)
  {
    if (ctx.Node is not ClassDeclarationSyntax classDecl)
      return null;

    ISymbol? symbol = ctx.SemanticModel.GetDeclaredSymbol(classDecl, ct);
    if (symbol is not INamedTypeSymbol classSymbol)
      return null;

    return ExtractRouteInfo(classSymbol);
  }

  private static AttributedRouteInfo? ExtractRouteInfo(INamedTypeSymbol classSymbol)
  {
    // Get the [NuruRoute] attribute
    AttributeData? routeAttribute = classSymbol.GetAttributes()
      .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == NuruRouteAttributeName);

    if (routeAttribute is null)
      return null;

    // Extract pattern from attribute constructor
    string pattern = routeAttribute.ConstructorArguments.Length > 0
      ? routeAttribute.ConstructorArguments[0].Value?.ToString() ?? ""
      : "";

    // Extract Description from named arguments
    string? description = null;
    foreach (KeyValuePair<string, TypedConstant> namedArg in routeAttribute.NamedArguments)
    {
      if (namedArg.Key == "Description")
        description = namedArg.Value.Value?.ToString();
    }

    // Check for [NuruRouteAlias]
    List<string> aliases = [];
    AttributeData? aliasAttribute = classSymbol.GetAttributes()
      .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == NuruRouteAliasAttributeName);

    if (aliasAttribute is { ConstructorArguments.Length: > 0 })
    {
      TypedConstant aliasArg = aliasAttribute.ConstructorArguments[0];
      if (aliasArg.Kind == TypedConstantKind.Array)
      {
        foreach (TypedConstant item in aliasArg.Values)
        {
          if (item.Value is string alias)
            aliases.Add(alias);
        }
      }
    }

    // Check for [NuruRouteGroup] on base classes
    string? groupPrefix = null;
    List<GroupOptionInfo> groupOptions = [];
    INamedTypeSymbol? currentType = classSymbol.BaseType;

    while (currentType is not null && currentType.SpecialType != SpecialType.System_Object)
    {
      AttributeData? groupAttribute = currentType.GetAttributes()
        .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == NuruRouteGroupAttributeName);

      if (groupAttribute is not null)
      {
        // Extract prefix from constructor
        if (groupAttribute.ConstructorArguments.Length > 0)
          groupPrefix = groupAttribute.ConstructorArguments[0].Value?.ToString();

        // Extract group options from base class properties
        foreach (ISymbol member in currentType.GetMembers())
        {
          if (member is IPropertySymbol property)
          {
            AttributeData? groupOptionAttr = property.GetAttributes()
              .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == GroupOptionAttributeName);

            if (groupOptionAttr is not null)
            {
              GroupOptionInfo groupOption = ExtractGroupOptionInfo(property, groupOptionAttr);
              groupOptions.Add(groupOption);
            }
          }
        }

        break; // Found the group, stop searching
      }

      currentType = currentType.BaseType;
    }

    // Extract parameters and options from class properties
    List<ParameterInfo> parameters = [];
    List<OptionInfo> options = [];

    foreach (ISymbol member in classSymbol.GetMembers())
    {
      if (member is not IPropertySymbol property)
        continue;

      // Check for [Parameter]
      AttributeData? paramAttr = property.GetAttributes()
        .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == ParameterAttributeName);

      if (paramAttr is not null)
      {
        ParameterInfo paramInfo = ExtractParameterInfo(property, paramAttr);
        parameters.Add(paramInfo);
        continue;
      }

      // Check for [Option]
      AttributeData? optionAttr = property.GetAttributes()
        .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == OptionAttributeName);

      if (optionAttr is not null)
      {
        OptionInfo optionInfo = ExtractOptionInfo(property, optionAttr);
        options.Add(optionInfo);
      }
    }

    return new AttributedRouteInfo(
      FullTypeName: classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
      TypeName: classSymbol.Name,
      Pattern: pattern,
      Description: description,
      Aliases: aliases,
      GroupPrefix: groupPrefix,
      GroupOptions: groupOptions,
      Parameters: parameters,
      Options: options
    );
  }

  private static ParameterInfo ExtractParameterInfo(IPropertySymbol property, AttributeData attr)
  {
    string? name = null;
    string? description = null;
    bool isCatchAll = false;

    foreach (KeyValuePair<string, TypedConstant> namedArg in attr.NamedArguments)
    {
      switch (namedArg.Key)
      {
        case "Name":
          name = namedArg.Value.Value?.ToString();
          break;
        case "Description":
          description = namedArg.Value.Value?.ToString();
          break;
        case "IsCatchAll":
          isCatchAll = namedArg.Value.Value is true;
          break;
      }
    }

    // Default name to property name in camelCase
    name ??= ToCamelCase(property.Name);

    // Determine if optional from nullability
    bool isOptional = property.NullableAnnotation == NullableAnnotation.Annotated ||
                      IsNullableValueType(property.Type);

    // Get type name for typed parameters
    string? typeName = GetSimpleTypeName(property.Type);

    return new ParameterInfo(
      Name: name,
      PropertyName: property.Name,
      Description: description,
      IsOptional: isOptional,
      IsCatchAll: isCatchAll,
      TypeName: typeName
    );
  }

  private static OptionInfo ExtractOptionInfo(IPropertySymbol property, AttributeData attr)
  {
    string longForm = "";
    string? shortForm = null;
    string? description = null;
    bool isRepeated = false;

    // Constructor arguments
    if (attr.ConstructorArguments.Length > 0)
      longForm = attr.ConstructorArguments[0].Value?.ToString() ?? "";
    if (attr.ConstructorArguments.Length > 1)
      shortForm = attr.ConstructorArguments[1].Value?.ToString();

    // Named arguments
    foreach (KeyValuePair<string, TypedConstant> namedArg in attr.NamedArguments)
    {
      switch (namedArg.Key)
      {
        case "Description":
          description = namedArg.Value.Value?.ToString();
          break;
        case "IsRepeated":
          isRepeated = namedArg.Value.Value is true;
          break;
      }
    }

    // Determine if this is a flag (bool) or valued option
    bool isFlag = property.Type.SpecialType == SpecialType.System_Boolean;

    // Determine if the value is optional (nullable type)
    bool isValueOptional = !isFlag && (
      property.NullableAnnotation == NullableAnnotation.Annotated ||
      IsNullableValueType(property.Type));

    // Get type name for typed options
    string? typeName = isFlag ? null : GetSimpleTypeName(property.Type);

    return new OptionInfo(
      LongForm: longForm,
      ShortForm: shortForm,
      PropertyName: property.Name,
      Description: description,
      IsFlag: isFlag,
      IsValueOptional: isValueOptional,
      IsRepeated: isRepeated,
      TypeName: typeName
    );
  }

  private static GroupOptionInfo ExtractGroupOptionInfo(IPropertySymbol property, AttributeData attr)
  {
    string longForm = "";
    string? shortForm = null;
    string? description = null;

    // Constructor arguments
    if (attr.ConstructorArguments.Length > 0)
      longForm = attr.ConstructorArguments[0].Value?.ToString() ?? "";
    if (attr.ConstructorArguments.Length > 1)
      shortForm = attr.ConstructorArguments[1].Value?.ToString();

    // Named arguments
    foreach (KeyValuePair<string, TypedConstant> namedArg in attr.NamedArguments)
    {
      if (namedArg.Key == "Description")
        description = namedArg.Value.Value?.ToString();
    }

    bool isFlag = property.Type.SpecialType == SpecialType.System_Boolean;
    bool isValueOptional = !isFlag && (
      property.NullableAnnotation == NullableAnnotation.Annotated ||
      IsNullableValueType(property.Type));

    string? typeName = isFlag ? null : GetSimpleTypeName(property.Type);

    return new GroupOptionInfo(
      LongForm: longForm,
      ShortForm: shortForm,
      PropertyName: property.Name,
      Description: description,
      IsFlag: isFlag,
      IsValueOptional: isValueOptional,
      TypeName: typeName
    );
  }

  private static string GenerateRegistrationCode(List<AttributedRouteInfo> routes)
  {
    System.Text.StringBuilder sb = new();

    sb.AppendLine("// <auto-generated/>");
    sb.AppendLine("// Generated by TimeWarp.Nuru.Analyzers - NuruAttributedRouteGenerator");
    sb.AppendLine("// DO NOT EDIT");
    sb.AppendLine();
    sb.AppendLine("#nullable enable");
    sb.AppendLine();
    sb.AppendLine("namespace TimeWarp.Nuru.Generated;");
    sb.AppendLine();

    // Generate route constants
    sb.AppendLine("/// <summary>");
    sb.AppendLine("/// Generated compiled routes for attributed request classes.");
    sb.AppendLine("/// </summary>");
    sb.AppendLine("[global::System.CodeDom.Compiler.GeneratedCode(\"TimeWarp.Nuru.Analyzers\", \"1.0.0\")]");
    sb.AppendLine("internal static class GeneratedAttributedRoutes");
    sb.AppendLine("{");

    foreach (AttributedRouteInfo route in routes)
    {
      GenerateRouteConstant(sb, route);
      sb.AppendLine();

      // Generate separate compiled routes for each alias
      foreach (string alias in route.Aliases)
      {
        GenerateAliasRouteConstant(sb, route, alias);
        sb.AppendLine();
      }
    }

    sb.AppendLine("}");
    sb.AppendLine();

    // Generate module initializer
    sb.AppendLine("/// <summary>");
    sb.AppendLine("/// Module initializer that registers attributed routes with NuruRouteRegistry.");
    sb.AppendLine("/// </summary>");
    sb.AppendLine("[global::System.CodeDom.Compiler.GeneratedCode(\"TimeWarp.Nuru.Analyzers\", \"1.0.0\")]");
    sb.AppendLine("internal static class GeneratedAttributedRouteRegistration");
    sb.AppendLine("{");
    sb.AppendLine("  [global::System.Runtime.CompilerServices.ModuleInitializer]");
    sb.AppendLine("  internal static void Register()");
    sb.AppendLine("  {");

    foreach (AttributedRouteInfo route in routes)
    {
      GenerateRegistrationCall(sb, route);

      // Also register aliases
      foreach (string alias in route.Aliases)
      {
        GenerateAliasRegistrationCall(sb, route, alias);
      }
    }

    sb.AppendLine("  }");
    sb.AppendLine("}");

    return sb.ToString();
  }

  private static void GenerateRouteConstant(System.Text.StringBuilder sb, AttributedRouteInfo route)
  {
    string safeName = MakeSafeName(route.TypeName);

    sb.Append(CultureInfo.InvariantCulture, $"  internal static readonly global::TimeWarp.Nuru.CompiledRoute __Route_{safeName} = ");
    sb.AppendLine("new global::TimeWarp.Nuru.RouteBuilder()");

    // Add group prefix literals
    if (!string.IsNullOrEmpty(route.GroupPrefix))
    {
      foreach (string literal in route.GroupPrefix.Split(' ', StringSplitOptions.RemoveEmptyEntries))
      {
        sb.Append(CultureInfo.InvariantCulture, $"    .WithLiteral(\"{EscapeString(literal)}\")");
        sb.AppendLine();
      }
    }

    // Add pattern literals
    if (!string.IsNullOrEmpty(route.Pattern))
    {
      foreach (string literal in route.Pattern.Split(' ', StringSplitOptions.RemoveEmptyEntries))
      {
        sb.Append(CultureInfo.InvariantCulture, $"    .WithLiteral(\"{EscapeString(literal)}\")");
        sb.AppendLine();
      }
    }

    // Add parameters
    foreach (ParameterInfo param in route.Parameters)
    {
      if (param.IsCatchAll)
      {
        sb.Append(CultureInfo.InvariantCulture, $"    .WithCatchAll(\"{EscapeString(param.Name)}\"");
        if (param.TypeName is not null)
          sb.Append(CultureInfo.InvariantCulture, $", type: \"{param.TypeName}\"");
        if (param.Description is not null)
          sb.Append(CultureInfo.InvariantCulture, $", description: \"{EscapeString(param.Description)}\"");
        sb.AppendLine(")");
      }
      else
      {
        sb.Append(CultureInfo.InvariantCulture, $"    .WithParameter(\"{EscapeString(param.Name)}\"");
        if (param.TypeName is not null)
          sb.Append(CultureInfo.InvariantCulture, $", type: \"{param.TypeName}\"");
        if (param.Description is not null)
          sb.Append(CultureInfo.InvariantCulture, $", description: \"{EscapeString(param.Description)}\"");
        if (param.IsOptional)
          sb.Append(", isOptional: true");
        sb.AppendLine(")");
      }
    }

    // Add group options
    foreach (GroupOptionInfo opt in route.GroupOptions)
    {
      GenerateOptionCall(sb, opt.LongForm, opt.ShortForm, opt.PropertyName, opt.Description,
        opt.IsFlag, opt.IsValueOptional, false, opt.TypeName);
    }

    // Add options
    foreach (OptionInfo opt in route.Options)
    {
      GenerateOptionCall(sb, opt.LongForm, opt.ShortForm, opt.PropertyName, opt.Description,
        opt.IsFlag, opt.IsValueOptional, opt.IsRepeated, opt.TypeName);
    }

    sb.AppendLine("    .Build();");

    // Generate pattern string for help display
    string patternString = BuildPatternString(route);
    sb.Append(CultureInfo.InvariantCulture, $"  internal const string __Pattern_{safeName} = \"{EscapeString(patternString)}\";");
    sb.AppendLine();
  }

  private static void GenerateOptionCall(System.Text.StringBuilder sb, string longForm, string? shortForm,
    string propertyName, string? description, bool isFlag, bool isValueOptional, bool isRepeated, string? typeName)
  {
    sb.Append(CultureInfo.InvariantCulture, $"    .WithOption(\"{EscapeString(longForm)}\"");

    if (shortForm is not null)
      sb.Append(CultureInfo.InvariantCulture, $", shortForm: \"{EscapeString(shortForm)}\"");

    if (!isFlag)
    {
      // Valued option
      sb.Append(CultureInfo.InvariantCulture, $", parameterName: \"{ToCamelCase(propertyName)}\"");
      sb.Append(", expectsValue: true");

      if (typeName is not null)
        sb.Append(CultureInfo.InvariantCulture, $", parameterType: \"{typeName}\"");

      if (isValueOptional)
        sb.Append(", parameterIsOptional: true");
    }

    if (description is not null)
      sb.Append(CultureInfo.InvariantCulture, $", description: \"{EscapeString(description)}\"");

    if (isRepeated)
      sb.Append(", isRepeated: true");

    // Make all options optional by default in attributed routes
    // (most CLI tools treat options as optional at runtime)
    sb.Append(", isOptionalFlag: true");

    sb.AppendLine(")");
  }

  private static void GenerateRegistrationCall(System.Text.StringBuilder sb, AttributedRouteInfo route)
  {
    string safeName = MakeSafeName(route.TypeName);
    string description = route.Description is not null ? $", \"{EscapeString(route.Description)}\"" : "";

    sb.Append(CultureInfo.InvariantCulture,
      $"    global::TimeWarp.Nuru.NuruRouteRegistry.Register(typeof({route.FullTypeName}), ");
    sb.Append(CultureInfo.InvariantCulture, $"GeneratedAttributedRoutes.__Route_{safeName}, ");
    sb.Append(CultureInfo.InvariantCulture, $"GeneratedAttributedRoutes.__Pattern_{safeName}");
    sb.Append(description);
    sb.AppendLine(");");
  }

  private static void GenerateAliasRegistrationCall(System.Text.StringBuilder sb, AttributedRouteInfo route, string alias)
  {
    string safeName = MakeSafeName(route.TypeName);
    string aliasSafeName = MakeSafeName(alias);
    string aliasPattern = BuildAliasPatternString(route, alias);
    string description = route.Description is not null ? $", \"{EscapeString(route.Description)}\"" : "";

    sb.Append(CultureInfo.InvariantCulture,
      $"    global::TimeWarp.Nuru.NuruRouteRegistry.Register(typeof({route.FullTypeName}), ");
    sb.Append(CultureInfo.InvariantCulture, $"GeneratedAttributedRoutes.__Route_{safeName}_Alias_{aliasSafeName}, ");
    sb.Append(CultureInfo.InvariantCulture, $"\"{EscapeString(aliasPattern)}\"");
    sb.Append(description);
    sb.AppendLine(");");
  }

  private static void GenerateAliasRouteConstant(System.Text.StringBuilder sb, AttributedRouteInfo route, string alias)
  {
    string safeName = MakeSafeName(route.TypeName);
    string aliasSafeName = MakeSafeName(alias);

    sb.Append(CultureInfo.InvariantCulture, $"  internal static readonly global::TimeWarp.Nuru.CompiledRoute __Route_{safeName}_Alias_{aliasSafeName} = ");
    sb.AppendLine("new global::TimeWarp.Nuru.RouteBuilder()");

    // Add group prefix literals (same as main route)
    if (!string.IsNullOrEmpty(route.GroupPrefix))
    {
      foreach (string literal in route.GroupPrefix.Split(' ', StringSplitOptions.RemoveEmptyEntries))
      {
        sb.Append(CultureInfo.InvariantCulture, $"    .WithLiteral(\"{EscapeString(literal)}\")");
        sb.AppendLine();
      }
    }

    // Add alias as the literal instead of the original pattern
    if (!string.IsNullOrEmpty(alias))
    {
      foreach (string literal in alias.Split(' ', StringSplitOptions.RemoveEmptyEntries))
      {
        sb.Append(CultureInfo.InvariantCulture, $"    .WithLiteral(\"{EscapeString(literal)}\")");
        sb.AppendLine();
      }
    }

    // Add parameters (same as main route)
    foreach (ParameterInfo param in route.Parameters)
    {
      if (param.IsCatchAll)
      {
        sb.Append(CultureInfo.InvariantCulture, $"    .WithCatchAll(\"{EscapeString(param.Name)}\"");
        if (param.TypeName is not null)
          sb.Append(CultureInfo.InvariantCulture, $", type: \"{param.TypeName}\"");
        if (param.Description is not null)
          sb.Append(CultureInfo.InvariantCulture, $", description: \"{EscapeString(param.Description)}\"");
        sb.AppendLine(")");
      }
      else
      {
        sb.Append(CultureInfo.InvariantCulture, $"    .WithParameter(\"{EscapeString(param.Name)}\"");
        if (param.TypeName is not null)
          sb.Append(CultureInfo.InvariantCulture, $", type: \"{param.TypeName}\"");
        if (param.Description is not null)
          sb.Append(CultureInfo.InvariantCulture, $", description: \"{EscapeString(param.Description)}\"");
        if (param.IsOptional)
          sb.Append(", isOptional: true");
        sb.AppendLine(")");
      }
    }

    // Add group options (same as main route)
    foreach (GroupOptionInfo opt in route.GroupOptions)
    {
      GenerateOptionCall(sb, opt.LongForm, opt.ShortForm, opt.PropertyName, opt.Description,
        opt.IsFlag, opt.IsValueOptional, false, opt.TypeName);
    }

    // Add options (same as main route)
    foreach (OptionInfo opt in route.Options)
    {
      GenerateOptionCall(sb, opt.LongForm, opt.ShortForm, opt.PropertyName, opt.Description,
        opt.IsFlag, opt.IsValueOptional, opt.IsRepeated, opt.TypeName);
    }

    sb.AppendLine("    .Build();");
  }

  private static string BuildPatternString(AttributedRouteInfo route)
  {
    List<string> parts = [];

    // Group prefix
    if (!string.IsNullOrEmpty(route.GroupPrefix))
      parts.Add(route.GroupPrefix);

    // Pattern
    if (!string.IsNullOrEmpty(route.Pattern))
      parts.Add(route.Pattern);

    // Parameters
    foreach (ParameterInfo param in route.Parameters)
    {
      if (param.IsCatchAll)
        parts.Add($"{{*{param.Name}}}");
      else if (param.IsOptional)
        parts.Add($"{{{param.Name}?}}");
      else
        parts.Add($"{{{param.Name}}}");
    }

    // Group options
    foreach (GroupOptionInfo opt in route.GroupOptions)
    {
      parts.Add(BuildOptionPatternPart(opt.LongForm, opt.ShortForm, opt.PropertyName, opt.IsFlag, opt.IsValueOptional));
    }

    // Options
    foreach (OptionInfo opt in route.Options)
    {
      parts.Add(BuildOptionPatternPart(opt.LongForm, opt.ShortForm, opt.PropertyName, opt.IsFlag, opt.IsValueOptional));
    }

    return string.Join(" ", parts);
  }

  private static string BuildAliasPatternString(AttributedRouteInfo route, string alias)
  {
    List<string> parts = [];

    // Alias replaces the pattern (but keeps group prefix if any)
    if (!string.IsNullOrEmpty(route.GroupPrefix))
      parts.Add(route.GroupPrefix);

    parts.Add(alias);

    // Parameters
    foreach (ParameterInfo param in route.Parameters)
    {
      if (param.IsCatchAll)
        parts.Add($"{{*{param.Name}}}");
      else if (param.IsOptional)
        parts.Add($"{{{param.Name}?}}");
      else
        parts.Add($"{{{param.Name}}}");
    }

    // Group options
    foreach (GroupOptionInfo opt in route.GroupOptions)
    {
      parts.Add(BuildOptionPatternPart(opt.LongForm, opt.ShortForm, opt.PropertyName, opt.IsFlag, opt.IsValueOptional));
    }

    // Options
    foreach (OptionInfo opt in route.Options)
    {
      parts.Add(BuildOptionPatternPart(opt.LongForm, opt.ShortForm, opt.PropertyName, opt.IsFlag, opt.IsValueOptional));
    }

    return string.Join(" ", parts);
  }

  private static string BuildOptionPatternPart(string longForm, string? shortForm, string propertyName,
    bool isFlag, bool isValueOptional)
  {
    string optPart = shortForm is not null
      ? $"--{longForm},-{shortForm}"
      : $"--{longForm}";

    if (!isFlag)
    {
      string paramName = ToCamelCase(propertyName);
      optPart += isValueOptional ? $" {{{paramName}?}}" : $" {{{paramName}}}";
    }

    return optPart;
  }

  private static bool IsNullableValueType(ITypeSymbol type)
    => type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T;

  private static string? GetSimpleTypeName(ITypeSymbol type)
  {
    // Handle nullable types
    if (type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T &&
        type is INamedTypeSymbol namedType &&
        namedType.TypeArguments.Length > 0)
    {
      type = namedType.TypeArguments[0];
    }

    return type.SpecialType switch
    {
      SpecialType.System_String => "string",
      SpecialType.System_Int32 => "int",
      SpecialType.System_Int64 => "long",
      SpecialType.System_Boolean => "bool",
      SpecialType.System_Double => "double",
      SpecialType.System_Single => "float",
      SpecialType.System_Decimal => "decimal",
      _ => type.Name.ToLowerInvariant()
    };
  }

  private static string ToCamelCase(string input)
  {
    if (string.IsNullOrEmpty(input))
      return input;

    return char.ToLowerInvariant(input[0]) + input[1..];
  }

  private static string EscapeString(string input)
    => input.Replace("\\", "\\\\", StringComparison.Ordinal).Replace("\"", "\\\"", StringComparison.Ordinal);

  private static string MakeSafeName(string typeName)
    => typeName
      .Replace(".", "_", StringComparison.Ordinal)
      .Replace("<", "_", StringComparison.Ordinal)
      .Replace(">", "_", StringComparison.Ordinal);

  // Data classes for extracted info
  private sealed record AttributedRouteInfo(
    string FullTypeName,
    string TypeName,
    string Pattern,
    string? Description,
    List<string> Aliases,
    string? GroupPrefix,
    List<GroupOptionInfo> GroupOptions,
    List<ParameterInfo> Parameters,
    List<OptionInfo> Options
  );

  private sealed record ParameterInfo(
    string Name,
    string PropertyName,
    string? Description,
    bool IsOptional,
    bool IsCatchAll,
    string? TypeName
  );

  private sealed record OptionInfo(
    string LongForm,
    string? ShortForm,
    string PropertyName,
    string? Description,
    bool IsFlag,
    bool IsValueOptional,
    bool IsRepeated,
    string? TypeName
  );

  private sealed record GroupOptionInfo(
    string LongForm,
    string? ShortForm,
    string PropertyName,
    string? Description,
    bool IsFlag,
    bool IsValueOptional,
    string? TypeName
  );
}
