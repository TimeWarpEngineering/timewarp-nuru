// Main emitter that generates the RunAsync interceptor method.
// This is the entry point for code emission, coordinating all other emitters.

namespace TimeWarp.Nuru.Generators;

using System.Text;

/// <summary>
/// Emits the complete generated interceptor source file.
/// This is the main entry point for the emission phase.
/// </summary>
internal static class InterceptorEmitter
{
  /// <summary>
  /// Generates the complete source code for the interceptor.
  /// </summary>
  /// <param name="model">The application model containing all route definitions.</param>
  /// <returns>The generated C# source code.</returns>
  public static string Emit(AppModel model)
  {
    StringBuilder sb = new();

    EmitHeader(sb);
    EmitNamespaceAndUsings(sb);
    EmitClassStart(sb);
    EmitInterceptsLocation(sb, model.InterceptSite);
    EmitMethodSignature(sb);
    EmitMethodBody(sb, model);
    EmitClassEnd(sb, model);

    return sb.ToString();
  }

  /// <summary>
  /// Emits the auto-generated header comment and nullable enable.
  /// </summary>
  private static void EmitHeader(StringBuilder sb)
  {
    sb.AppendLine("// <auto-generated/>");
    sb.AppendLine("// This code was generated by TimeWarp.Nuru V2 source generator.");
    sb.AppendLine("// Do not modify this file directly.");
    sb.AppendLine("#nullable enable");
    sb.AppendLine();
  }

  /// <summary>
  /// Emits the namespace declaration and using statements.
  /// </summary>
  private static void EmitNamespaceAndUsings(StringBuilder sb)
  {
    sb.AppendLine("namespace TimeWarp.Nuru.Generated;");
    sb.AppendLine();
    sb.AppendLine("using System.Runtime.CompilerServices;");
    sb.AppendLine("using System.Threading;");
    sb.AppendLine("using System.Threading.Tasks;");
    sb.AppendLine();
  }

  /// <summary>
  /// Emits the file-scoped static class declaration.
  /// </summary>
  private static void EmitClassStart(StringBuilder sb)
  {
    sb.AppendLine("file static class GeneratedInterceptor");
    sb.AppendLine("{");
  }

  /// <summary>
  /// Emits the [InterceptsLocation] attribute for the RunAsync call site.
  /// </summary>
  private static void EmitInterceptsLocation(StringBuilder sb, InterceptSiteModel site)
  {
    // The InterceptsLocation attribute requires the file path, line, and character position
    // Note: File paths need to use verbatim string literals to handle backslashes
    sb.AppendLine(CultureInfo.InvariantCulture,
      $"  [InterceptsLocation(@\"{EscapeString(site.FilePath)}\", line: {site.Line}, character: {site.Column})]");
  }

  /// <summary>
  /// Emits the method signature for the intercepted RunAsync method.
  /// </summary>
  private static void EmitMethodSignature(StringBuilder sb)
  {
    sb.AppendLine("  public static async Task<int> RunAsync_Intercepted");
    sb.AppendLine("  (");
    sb.AppendLine("    this NuruCoreApp app,");
    sb.AppendLine("    string[] args,");
    sb.AppendLine("    CancellationToken cancellationToken = default");
    sb.AppendLine("  )");
    sb.AppendLine("  {");
  }

  /// <summary>
  /// Emits the complete method body including all route matching logic.
  /// </summary>
  private static void EmitMethodBody(StringBuilder sb, AppModel model)
  {
    // Built-in flags: --help, --version, --capabilities
    EmitBuiltInFlags(sb, model);

    // Route matching - emit in specificity order (highest first)
    foreach (RouteDefinition route in model.RoutesBySpecificity)
    {
      RouteMatcherEmitter.Emit(sb, route);
    }

    // No match fallback
    EmitNoMatch(sb);
  }

  /// <summary>
  /// Emits handling for built-in flags (--help, --version, --capabilities).
  /// </summary>
  private static void EmitBuiltInFlags(StringBuilder sb, AppModel model)
  {
    // --help flag
    if (model.HasHelp)
    {
      sb.AppendLine("    // Built-in: --help");
      sb.AppendLine("    if (args is [\"--help\" or \"-h\"])");
      sb.AppendLine("    {");
      sb.AppendLine("      PrintHelp(app.Terminal);");
      sb.AppendLine("      return 0;");
      sb.AppendLine("    }");
      sb.AppendLine();
    }

    // --version flag (always available)
    sb.AppendLine("    // Built-in: --version");
    sb.AppendLine("    if (args is [\"--version\"])");
    sb.AppendLine("    {");
    sb.AppendLine("      PrintVersion(app.Terminal);");
    sb.AppendLine("      return 0;");
    sb.AppendLine("    }");
    sb.AppendLine();

    // --capabilities flag (always available for AI tools)
    sb.AppendLine("    // Built-in: --capabilities (for AI tools)");
    sb.AppendLine("    if (args is [\"--capabilities\"])");
    sb.AppendLine("    {");
    sb.AppendLine("      PrintCapabilities(app.Terminal);");
    sb.AppendLine("      return 0;");
    sb.AppendLine("    }");
    sb.AppendLine();
  }

  /// <summary>
  /// Emits the no-match fallback code.
  /// </summary>
  private static void EmitNoMatch(StringBuilder sb)
  {
    sb.AppendLine("    // No route matched");
    sb.AppendLine("    app.Terminal.WriteError(\"Unknown command. Use --help for usage.\");");
    sb.AppendLine("    return 1;");
    sb.AppendLine("  }");
  }

  /// <summary>
  /// Emits the closing of the class and helper methods.
  /// </summary>
  private static void EmitClassEnd(StringBuilder sb, AppModel model)
  {
    sb.AppendLine();
    HelpEmitter.Emit(sb, model);
    sb.AppendLine();
    VersionEmitter.Emit(sb, model);
    sb.AppendLine();
    CapabilitiesEmitter.Emit(sb, model);
    sb.AppendLine("}");
  }

  /// <summary>
  /// Escapes a string for use in C# source code.
  /// </summary>
  private static string EscapeString(string value)
  {
    return value
      .Replace("\\", "\\\\", StringComparison.Ordinal)
      .Replace("\"", "\\\"", StringComparison.Ordinal)
      .Replace("\n", "\\n", StringComparison.Ordinal)
      .Replace("\r", "\\r", StringComparison.Ordinal)
      .Replace("\t", "\\t", StringComparison.Ordinal);
  }
}
