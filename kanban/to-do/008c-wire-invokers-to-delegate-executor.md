# Wire Invokers to DelegateExecutor

## Description

Replace DynamicInvoke in DelegateExecutor with generated typed invokers. This is the integration point where the source-generated code connects to the runtime execution path.

## Parent

008-implement-source-generators-for-reflection-free-routing

## Dependencies

- 008b-generate-typed-invoker-methods

## Requirements

- Create registry mapping routes to generated invokers
- Modify DelegateExecutor to use registry lookup
- Fall back to DynamicInvoke if no generated invoker exists (for backwards compatibility)
- Ensure all existing tests still pass
- Maintain API compatibility

## Checklist

### Implementation
- [ ] Generate route-to-invoker registry
- [ ] Create lookup mechanism by route pattern or signature hash
- [ ] Modify DelegateExecutor to check registry first
- [ ] Implement DynamicInvoke fallback for unregistered routes
- [ ] Add diagnostic/debug logging for invoker selection
- [ ] Handle async invoker coordination with existing async flow

### Generated Registry Shape
```csharp
// <auto-generated/>
internal static class GeneratedRouteRegistry
{
    private static readonly Dictionary<string, Func<Delegate, object?[], object?>> Invokers = new()
    {
        ["Action<string>"] = GeneratedRouteInvokers.Invoke_Action_String,
        ["Func<int,int,int>"] = GeneratedRouteInvokers.Invoke_Func_Int_Int_Int,
    };
    
    public static bool TryGetInvoker(string signatureKey, out Func<Delegate, object?[], object?>? invoker)
        => Invokers.TryGetValue(signatureKey, out invoker);
}
```

### Testing
- [ ] All existing routing tests pass
- [ ] Verify generated invokers are used when available
- [ ] Verify fallback to DynamicInvoke works
- [ ] Test mixed scenario (some generated, some not)
- [ ] Performance comparison test

## Notes

The registry key strategy is important:
- Could use route pattern string
- Could use delegate signature hash
- Could use synthetic ID from source generator

Consider adding telemetry to track which invocation path is used during development/debugging.
