#!/usr/bin/dotnet --

using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;

// Get the repo root
string scriptDir = AppContext.GetData("EntryPointFileDirectoryPath") as string
  ?? throw new InvalidOperationException("Could not get entry point directory");
string repoRoot = Path.GetFullPath(Path.Combine(scriptDir, ".."));
string testsDir = Path.Combine(repoRoot, "tests");
string benchmarksDir = Path.Combine(repoRoot, "benchmarks");

// Projects that need InternalsVisibleTo
string[] outputFiles =
[
  Path.Combine(repoRoot, "source/timewarp-nuru/internals-visible-to.g.cs"),
  Path.Combine(repoRoot, "source/timewarp-nuru-core/internals-visible-to.g.cs"),
  Path.Combine(repoRoot, "source/timewarp-nuru-parsing/internals-visible-to.g.cs"),
  Path.Combine(repoRoot, "source/timewarp-nuru-mcp/internals-visible-to.g.cs"),
  Path.Combine(repoRoot, "source/timewarp-nuru-completion/internals-visible-to.g.cs"),
  Path.Combine(repoRoot, "source/timewarp-nuru-repl/internals-visible-to.g.cs")
];

// Helper to extract AssemblyName from csproj, or return null if not found
static string? GetAssemblyNameFromCsproj(string csprojPath)
{
  string content = File.ReadAllText(csprojPath);
  Match match = Regex.Match(content, @"<AssemblyName>([^<]+)</AssemblyName>");
  return match.Success ? match.Groups[1].Value : null;
}

// Find all .cs files in Tests directory (single-file scripts / runfiles)
List<string> testFiles = Directory.GetFiles(testsDir, "*.cs", SearchOption.AllDirectories)
  .Where(f => !f.Contains("/obj/", StringComparison.Ordinal) && !f.Contains("/bin/", StringComparison.Ordinal))
  .Select(Path.GetFileNameWithoutExtension)
  .Where(name => !string.IsNullOrEmpty(name))
  .ToList()!;

// Find all .csproj files in Tests directory and extract AssemblyName (or use file name as fallback)
List<string> testProjects = Directory.GetFiles(testsDir, "*.csproj", SearchOption.AllDirectories)
  .Where(f => !f.Contains("/obj/", StringComparison.Ordinal) && !f.Contains("/bin/", StringComparison.Ordinal))
  .Select(f => GetAssemblyNameFromCsproj(f) ?? Path.GetFileNameWithoutExtension(f))
  .Where(name => !string.IsNullOrEmpty(name))
  .ToList()!;

// Find all .csproj files in Benchmarks directory and extract AssemblyName (or use file name as fallback)
List<string> benchmarkProjects = Directory.GetFiles(benchmarksDir, "*.csproj", SearchOption.AllDirectories)
  .Where(f => !f.Contains("/obj/", StringComparison.Ordinal) && !f.Contains("/bin/", StringComparison.Ordinal))
  .Select(f => GetAssemblyNameFromCsproj(f) ?? Path.GetFileNameWithoutExtension(f))
  .Where(name => !string.IsNullOrEmpty(name))
  .ToList()!;

// Also find directories with Directory.Build.props (test projects without .csproj)
List<string> testDirectories = Directory.GetFiles(testsDir, "Directory.Build.props", SearchOption.AllDirectories)
  .Where(f => !f.Contains("/obj/", StringComparison.Ordinal) && !f.Contains("/bin/", StringComparison.Ordinal))
  .Select(f => Path.GetFileName(Path.GetDirectoryName(f)))
  .Where(name => !string.IsNullOrEmpty(name))
  .ToList()!;

testProjects.AddRange(testDirectories);
testProjects.AddRange(benchmarkProjects);

// Combine and deduplicate
testFiles.AddRange(testProjects);
testFiles = [.. testFiles.Distinct().Order()];

Console.WriteLine(string.Create(CultureInfo.InvariantCulture, $"Found {testFiles.Count} test assemblies"));

// Generate the InternalsVisibleTo attributes
StringBuilder sb = new();
sb.AppendLine("// <auto-generated />");
sb.AppendLine("// This file is generated by scripts/generate-internals-visible-to.cs");
sb.AppendLine("// DO NOT EDIT MANUALLY");
sb.AppendLine();
sb.AppendLine("using System.Runtime.CompilerServices;");
sb.AppendLine();

foreach (string testName in testFiles)
{
  sb.Append(CultureInfo.InvariantCulture, $"[assembly: InternalsVisibleTo(\"{testName}\")]");
  sb.AppendLine();
}

string content = sb.ToString();

// Write the file to all projects
foreach (string outputFile in outputFiles)
{
  File.WriteAllText(outputFile, content);
  Console.WriteLine($"Generated {outputFile}");
}

Console.WriteLine($"Added InternalsVisibleTo for {testFiles.Count} test assemblies");

return 0;
