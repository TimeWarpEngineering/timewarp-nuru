namespace TimeWarp.Nuru;

/// <summary>
/// Source generator that creates route registration code for classes with [NuruRoute] attribute.
/// Generates CompiledRouteBuilder calls and ModuleInitializer registration code.
/// </summary>
/// <remarks>
/// This generator is split into multiple partial files for maintainability:
/// <list type="bullet">
///   <item><description><c>nuru-attributed-route-generator.cs</c> - Main file with Initialize(), syntax detection, record types, and utility methods</description></item>
///   <item><description><c>nuru-attributed-route-generator.extraction.cs</c> - Attribute extraction methods (ExtractRouteInfo, ExtractParameterInfo, ExtractOptionInfo, ExtractGroupOptionInfo)</description></item>
///   <item><description><c>nuru-attributed-route-generator.codegen.cs</c> - Code generation methods (GenerateRegistrationCode, GenerateRouteConstant, GenerateOptionCall, GenerateRegistrationCall, GenerateAliasRegistrationCall, GenerateAliasRouteConstant)</description></item>
///   <item><description><c>nuru-attributed-route-generator.patterns.cs</c> - Pattern building methods (BuildPatternString, BuildAliasPatternString, BuildOptionPatternPart, InferMessageType)</description></item>
/// </list>
/// </remarks>
[Generator]
public partial class NuruAttributedRouteGenerator : IIncrementalGenerator
{
  private const string NuruRouteAttributeName = "TimeWarp.Nuru.NuruRouteAttribute";
  private const string NuruRouteAliasAttributeName = "TimeWarp.Nuru.NuruRouteAliasAttribute";
  private const string NuruRouteGroupAttributeName = "TimeWarp.Nuru.NuruRouteGroupAttribute";
  private const string ParameterAttributeName = "TimeWarp.Nuru.ParameterAttribute";
  private const string OptionAttributeName = "TimeWarp.Nuru.OptionAttribute";
  private const string GroupOptionAttributeName = "TimeWarp.Nuru.GroupOptionAttribute";

  public void Initialize(IncrementalGeneratorInitializationContext context)
  {
    // Skip if V2 generator is enabled
    IncrementalValueProvider<bool> useNewGen = GeneratorHelpers.GetUseNewGenProvider(context);

    // Find all class declarations that might have [NuruRoute] attribute
    IncrementalValuesProvider<AttributedRouteInfo?> attributedRoutes = context.SyntaxProvider
      .CreateSyntaxProvider(
        predicate: static (node, _) => IsClassWithNuruRouteAttribute(node),
        transform: static (ctx, ct) => ExtractRouteInfoFromSyntax(ctx, ct))
      .Where(static info => info is not null);

    // Collect all routes
    IncrementalValueProvider<ImmutableArray<AttributedRouteInfo?>> collectedRoutes = attributedRoutes.Collect();

    // Combine with UseNewGen flag
    IncrementalValueProvider<(ImmutableArray<AttributedRouteInfo?> Routes, bool SkipGeneration)> combined =
      collectedRoutes.Combine(useNewGen);

    // Generate source code
    context.RegisterSourceOutput(combined, static (ctx, data) =>
    {
      if (data.SkipGeneration)
        return;

      ImmutableArray<AttributedRouteInfo?> routes = data.Routes;

      // Always generate a marker comment so we know the generator ran
      string header = "// <auto-generated/>\n// Generator ran. Routes found: " + routes.Length + "\n";

      if (routes.IsDefaultOrEmpty)
      {
        ctx.AddSource("GeneratedAttributedRoutes.g.cs", header + "// No routes found\n");
        return;
      }

      List<AttributedRouteInfo> validRoutes = [.. routes
        .Where(r => r is not null)
        .Cast<AttributedRouteInfo>()];

      if (validRoutes.Count == 0)
      {
        ctx.AddSource("GeneratedAttributedRoutes.g.cs", header + "// No valid routes\n");
        return;
      }

      string source = GenerateRegistrationCode(validRoutes);
      ctx.AddSource("GeneratedAttributedRoutes.g.cs", source);
    });
  }

  private static bool IsClassWithNuruRouteAttribute(Microsoft.CodeAnalysis.SyntaxNode node)
  {
    if (node is not ClassDeclarationSyntax classDecl)
      return false;

    // Check if class has any attribute that looks like NuruRoute
    foreach (AttributeListSyntax attrList in classDecl.AttributeLists)
    {
      foreach (AttributeSyntax attr in attrList.Attributes)
      {
        string name = attr.Name.ToString();
        if (name is "NuruRoute" or "NuruRouteAttribute" or "TimeWarp.Nuru.NuruRoute" or "TimeWarp.Nuru.NuruRouteAttribute")
          return true;
      }
    }

    return false;
  }

  private static AttributedRouteInfo? ExtractRouteInfoFromSyntax(GeneratorSyntaxContext ctx, CancellationToken ct)
  {
    if (ctx.Node is not ClassDeclarationSyntax classDecl)
      return null;

    ISymbol? symbol = ctx.SemanticModel.GetDeclaredSymbol(classDecl, ct);
    if (symbol is not INamedTypeSymbol classSymbol)
      return null;

    return ExtractRouteInfo(classSymbol);
  }

  #region Utility Methods

  private static bool IsNullableValueType(ITypeSymbol type)
    => type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T;

  private static string? GetSimpleTypeName(ITypeSymbol type)
  {
    // Handle nullable types
    if (type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T &&
        type is INamedTypeSymbol namedType &&
        namedType.TypeArguments.Length > 0)
    {
      type = namedType.TypeArguments[0];
    }

    return type.SpecialType switch
    {
      SpecialType.System_String => "string",
      SpecialType.System_Int32 => "int",
      SpecialType.System_Int64 => "long",
      SpecialType.System_Boolean => "bool",
      SpecialType.System_Double => "double",
      SpecialType.System_Single => "float",
      SpecialType.System_Decimal => "decimal",
      _ => type.Name.ToLowerInvariant()
    };
  }

  private static string ToCamelCase(string input)
  {
    if (string.IsNullOrEmpty(input))
      return input;

    return char.ToLowerInvariant(input[0]) + input[1..];
  }

  private static string EscapeString(string input)
    => input.Replace("\\", "\\\\", StringComparison.Ordinal).Replace("\"", "\\\"", StringComparison.Ordinal);

  private static string MakeSafeName(string typeName)
    => typeName
      .Replace(".", "_", StringComparison.Ordinal)
      .Replace("<", "_", StringComparison.Ordinal)
      .Replace(">", "_", StringComparison.Ordinal);

  #endregion

  #region Record Types

  // Data classes for extracted info
  private sealed record AttributedRouteInfo(
    string FullTypeName,
    string TypeName,
    string Pattern,
    string? Description,
    List<string> Aliases,
    string? GroupPrefix,
    List<GroupOptionInfo> GroupOptions,
    List<ParameterInfo> Parameters,
    List<OptionInfo> Options,
    string InferredMessageType // "Unspecified", "Query", "Command", "IdempotentCommand"
  );

  private sealed record ParameterInfo(
    string Name,
    string PropertyName,
    string? Description,
    bool IsOptional,
    bool IsCatchAll,
    string? TypeName,
    int Order
  );

  private sealed record OptionInfo(
    string LongForm,
    string? ShortForm,
    string PropertyName,
    string? Description,
    bool IsFlag,
    bool IsValueOptional,
    bool IsRepeated,
    string? TypeName
  );

  private sealed record GroupOptionInfo(
    string LongForm,
    string? ShortForm,
    string PropertyName,
    string? Description,
    bool IsFlag,
    bool IsValueOptional,
    string? TypeName
  );

  #endregion
}
