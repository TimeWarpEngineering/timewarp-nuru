// Main emitter that generates the RunAsync interceptor methods.
// This is the entry point for code emission, coordinating all other emitters.
//
// Key design: Each app instance gets its own interceptor method with isolated routes.
// This ensures route patterns don't leak between different NuruCoreApp instances.

namespace TimeWarp.Nuru.Generators;

using System.Text;

/// <summary>
/// Emits the complete generated interceptor source file.
/// This is the main entry point for the emission phase.
/// </summary>
internal static class InterceptorEmitter
{
  /// <summary>
  /// Generates the complete source code for the interceptor.
  /// </summary>
  /// <param name="model">The generator model containing all apps and routes.</param>
  /// <returns>The generated C# source code.</returns>
  public static string Emit(GeneratorModel model)
  {
    StringBuilder sb = new();

    EmitHeader(sb);
    EmitInterceptsLocationAttribute(sb);
    EmitNamespaceAndUsings(sb, model);
    EmitClassStart(sb);

    // Emit shared infrastructure (command classes, service fields, behaviors, logging)
    EmitCommandClasses(sb, model);
    EmitServiceFields(sb, model.AllServices);
    EmitLoggingFactoryFields(sb, model);

    // Determine the logger factory field name for behaviors (use first app with logging, or null)
    string? loggerFactoryFieldName = GetFirstLoggerFactoryFieldName(model);
    BehaviorEmitter.EmitBehaviorFields(sb, [.. model.AllBehaviors], [.. model.AllServices], loggerFactoryFieldName);

    // Emit per-app interceptor methods
    for (int appIndex = 0; appIndex < model.Apps.Length; appIndex++)
    {
      AppModel app = model.Apps[appIndex];
      EmitAppInterceptorMethod(sb, app, appIndex, model);
    }

    EmitClassEnd(sb, model);

    return sb.ToString();
  }

  /// <summary>
  /// Emits a single interceptor method for one app.
  /// Each app gets its own method with its own [InterceptsLocation] attributes and routes.
  /// </summary>
  private static void EmitAppInterceptorMethod(StringBuilder sb, AppModel app, int appIndex, GeneratorModel model)
  {
    // Emit [InterceptsLocation] attributes for this app's RunAsync calls
    foreach (InterceptSiteModel site in app.InterceptSites)
    {
      sb.AppendLine($"  {site.GetAttributeSyntax()}");
    }

    // Method signature - use index suffix for uniqueness when multiple apps
    string methodSuffix = model.Apps.Length > 1 ? $"_{appIndex}" : "";
    sb.AppendLine($"  public static async Task<int> RunAsync_Intercepted{methodSuffix}");
    sb.AppendLine("  (");
    sb.AppendLine("    this NuruCoreApp app,");
    sb.AppendLine("    string[] args");
    sb.AppendLine("  )");
    sb.AppendLine("  {");

    // If logging is configured, wrap in try-finally for proper disposal
    if (app.HasLogging)
    {
      sb.AppendLine("    try");
      sb.AppendLine("    {");
    }

    // Method body with this app's routes only
    EmitMethodBody(sb, app, appIndex, model);

    // Close try-finally if logging is configured
    if (app.HasLogging)
    {
      sb.AppendLine("    }");
      sb.AppendLine("    finally");
      sb.AppendLine("    {");
      string factoryFieldName = GetLoggerFactoryFieldName(appIndex, model.Apps.Length);
      sb.AppendLine($"      ({factoryFieldName} as global::System.IDisposable)?.Dispose();");
      sb.AppendLine("    }");
    }

    sb.AppendLine("  }");
    sb.AppendLine();
  }

  /// <summary>
  /// Emits the InterceptsLocationAttribute definition.
  /// In .NET 10 / C# 14, interceptors use the new versioned constructor:
  /// InterceptsLocationAttribute(int version, string data)
  /// We use 'file' scope so it doesn't conflict with other generators that may define it.
  /// </summary>
  private static void EmitInterceptsLocationAttribute(StringBuilder sb)
  {
    sb.AppendLine("namespace System.Runtime.CompilerServices");
    sb.AppendLine("{");
    sb.AppendLine("  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]");
    sb.AppendLine("  file sealed class InterceptsLocationAttribute : global::System.Attribute");
    sb.AppendLine("  {");
    sb.AppendLine("    public InterceptsLocationAttribute(int version, string data)");
    sb.AppendLine("    {");
    sb.AppendLine("      Version = version;");
    sb.AppendLine("      Data = data;");
    sb.AppendLine("    }");
    sb.AppendLine();
    sb.AppendLine("    public int Version { get; }");
    sb.AppendLine("    public string Data { get; }");
    sb.AppendLine("  }");
    sb.AppendLine("}");
    sb.AppendLine();
  }

  /// <summary>
  /// Emits the auto-generated header comment, pragma warning disable, and nullable enable.
  /// </summary>
  private static void EmitHeader(StringBuilder sb)
  {
    sb.AppendLine("// <auto-generated/>");
    sb.AppendLine("// This code was generated by TimeWarp.Nuru V2 source generator.");
    sb.AppendLine("// Do not modify this file directly.");
    sb.AppendLine("#pragma warning disable");
    sb.AppendLine("#nullable enable");
    sb.AppendLine();
  }

  /// <summary>
  /// Emits the namespace declaration and using statements.
  /// Uses block-scoped namespace to be compatible with the InterceptsLocationAttribute
  /// which is in a separate namespace block in the same file.
  /// </summary>
  private static void EmitNamespaceAndUsings(StringBuilder sb, GeneratorModel model)
  {
    sb.AppendLine("namespace TimeWarp.Nuru.Generated");
    sb.AppendLine("{");
    sb.AppendLine();

    // Default usings required by generated code
    sb.AppendLine("using global::System.Linq;");
    sb.AppendLine("using global::System.Net.Http;");
    sb.AppendLine("using global::System.Reflection;");
    sb.AppendLine("using global::System.Runtime.CompilerServices;");
    sb.AppendLine("using global::System.Text.Json;");
    sb.AppendLine("using global::System.Text.Json.Serialization;");
    sb.AppendLine("using global::System.Text.RegularExpressions;");
    sb.AppendLine("using global::System.Threading.Tasks;");
    sb.AppendLine("using global::Microsoft.Extensions.Configuration;");
    sb.AppendLine("using global::Microsoft.Extensions.Configuration.Json;");
    sb.AppendLine("using global::Microsoft.Extensions.Configuration.EnvironmentVariables;");
    sb.AppendLine("#if DEBUG");
    sb.AppendLine("using global::Microsoft.Extensions.Configuration.UserSecrets;");
    sb.AppendLine("#endif");
    sb.AppendLine("using global::TimeWarp.Nuru;");
    sb.AppendLine("using global::TimeWarp.Terminal;");

    // User-defined usings from source file
    if (model.UserUsings.Length > 0)
    {
      sb.AppendLine();
      sb.AppendLine("// User-defined usings");
      foreach (string userUsing in model.UserUsings)
      {
        sb.AppendLine(userUsing);
      }
    }

    sb.AppendLine();
  }

  /// <summary>
  /// Emits the file-scoped static class declaration.
  /// </summary>
  private static void EmitClassStart(StringBuilder sb)
  {
    sb.AppendLine("file static class GeneratedInterceptor");
    sb.AppendLine("{");
  }

  /// <summary>
  /// Emits generated command classes for delegate routes.
  /// These provide command instances for behaviors.
  /// </summary>
  private static void EmitCommandClasses(StringBuilder sb, GeneratorModel model)
  {
    // Emit command classes for all routes across all apps
    CommandClassEmitter.EmitCommandClasses(sb, model.AllRoutes);
  }

  /// <summary>
  /// Emits static Lazy fields for Singleton and Scoped services.
  /// These provide thread-safe lazy initialization for cached service instances.
  /// </summary>
  private static void EmitServiceFields(StringBuilder sb, IEnumerable<ServiceDefinition> services)
  {
    // Only emit fields for Singleton and Scoped services (not Transient)
    // Materialize to array to avoid multiple enumeration
    ServiceDefinition[] cachedServices =
    [
      .. services
        .Where(s => s.Lifetime is ServiceLifetime.Singleton or ServiceLifetime.Scoped)
        .DistinctBy(s => s.ImplementationTypeName) // Avoid duplicates if same impl registered multiple times
    ];

    if (cachedServices.Length == 0)
      return;

    sb.AppendLine("  // Static service fields (thread-safe lazy initialization)");

    foreach (ServiceDefinition service in cachedServices)
    {
      string fieldName = GetServiceFieldName(service.ImplementationTypeName);
      sb.AppendLine(
        $"  private static readonly global::System.Lazy<{service.ImplementationTypeName}> {fieldName} = new(() => new {service.ImplementationTypeName}());");
    }

    sb.AppendLine();
  }

  /// <summary>
  /// Emits static LoggerFactory fields for apps with logging configured.
  /// Each app gets its own factory to support different logging configurations.
  /// </summary>
  private static void EmitLoggingFactoryFields(StringBuilder sb, GeneratorModel model)
  {
    // Only emit for apps that have logging configured
    bool hasAnyLogging = model.Apps.Any(a => a.HasLogging);
    if (!hasAnyLogging)
      return;

    sb.AppendLine("  // Static LoggerFactory fields (one per app with logging configured)");

    for (int appIndex = 0; appIndex < model.Apps.Length; appIndex++)
    {
      AppModel app = model.Apps[appIndex];
      if (app.LoggingConfiguration is null)
        continue;

      string fieldName = GetLoggerFactoryFieldName(appIndex, model.Apps.Length);
      string lambdaBody = app.LoggingConfiguration.ConfigurationLambdaBody.TrimEnd();

      // Ensure lambda body ends with semicolon
      if (!lambdaBody.EndsWith(';'))
        lambdaBody += ";";

      sb.AppendLine($"  private static readonly global::Microsoft.Extensions.Logging.ILoggerFactory {fieldName} =");
      sb.AppendLine("    global::Microsoft.Extensions.Logging.LoggerFactory.Create(builder =>");
      sb.AppendLine("    {");
      sb.AppendLine($"      {lambdaBody}");
      sb.AppendLine("    });");
    }

    sb.AppendLine();
  }

  /// <summary>
  /// Gets the field name for a LoggerFactory instance.
  /// </summary>
  /// <param name="appIndex">Index of the app (for unique naming with multiple apps).</param>
  /// <param name="totalApps">Total number of apps.</param>
  /// <returns>Field name like "__loggerFactory" or "__loggerFactory_0".</returns>
  internal static string GetLoggerFactoryFieldName(int appIndex, int totalApps)
  {
    // Use simple name if only one app, otherwise add suffix for uniqueness
    return totalApps > 1 ? $"__loggerFactory_{appIndex}" : "__loggerFactory";
  }

  /// <summary>
  /// Gets the logger factory field name for the first app that has logging configured.
  /// Used for shared behaviors that need a logger.
  /// </summary>
  /// <param name="model">The generator model.</param>
  /// <returns>The field name, or null if no app has logging configured.</returns>
  private static string? GetFirstLoggerFactoryFieldName(GeneratorModel model)
  {
    for (int i = 0; i < model.Apps.Length; i++)
    {
      if (model.Apps[i].HasLogging)
      {
        return GetLoggerFactoryFieldName(i, model.Apps.Length);
      }
    }

    return null;
  }

  /// <summary>
  /// Gets the static field name for a service implementation type.
  /// </summary>
  /// <param name="implementationTypeName">Fully qualified implementation type name.</param>
  /// <returns>Field name like "__svc_MyApp_Services_Greeter".</returns>
  internal static string GetServiceFieldName(string implementationTypeName)
  {
    string name = implementationTypeName;

    // Remove global:: prefix
    if (name.StartsWith("global::", StringComparison.Ordinal))
      name = name[8..];

    // Replace dots with underscores for valid C# identifier
    return "__svc_" + name.Replace(".", "_", StringComparison.Ordinal);
  }

  /// <summary>
  /// Emits the complete method body including all route matching logic.
  /// </summary>
  private static void EmitMethodBody(StringBuilder sb, AppModel app, int appIndex, GeneratorModel model)
  {
    // Configuration setup (if AddConfiguration was called)
    if (app.HasConfiguration)
    {
      ConfigurationEmitter.Emit(sb);
    }

    // Filter out configuration override args before route matching
    // Config overrides follow pattern: --Section:Key=value (starts with -- and contains :)
    // This allows AddCommandLine(args) to process them while route matching ignores them
    EmitConfigArgFiltering(sb);

    // Built-in flags: --help, --version, --capabilities
    EmitBuiltInFlags(sb, app);

    // Route matching - emit this app's routes in specificity order (highest first)
    // Filter endpoints based on app's discovery mode (DiscoverEndpoints or Map<T> calls)
    ImmutableArray<RouteDefinition> endpointsForApp = FilterEndpointsForApp(app, model.AttributedRoutes);
    IEnumerable<RouteDefinition> allRoutes = app.RoutesBySpecificity.Concat(endpointsForApp);

    // Build a lookup from route to its original index for command class naming
    // IMPORTANT: Use only this app's routes (plus filtered endpoints), not all routes from all apps
    // Using model.AllRoutes would cause route index collisions between different apps
    List<RouteDefinition> allRoutesOrdered = [.. app.Routes.Concat(endpointsForApp)];

    foreach (RouteDefinition route in allRoutes.OrderByDescending(r => r.ComputedSpecificity))
    {
      // Find the route's original index in model.AllRoutes
      int routeIndex = allRoutesOrdered.FindIndex(r => ReferenceEquals(r, route));
      if (routeIndex < 0)
      {
        // For attributed routes not in allRoutesOrdered, use a new index
        routeIndex = allRoutesOrdered.Count;
        allRoutesOrdered.Add(route);
      }

      RouteMatcherEmitter.Emit(sb, route, routeIndex, app.Services, app.Behaviors, app.CustomConverters);
    }

    // No match fallback
    EmitNoMatch(sb);
  }

  /// <summary>
  /// Filters endpoints based on the app's discovery mode.
  /// </summary>
  /// <param name="app">The app model with discovery settings.</param>
  /// <param name="allEndpoints">All discovered endpoint classes.</param>
  /// <returns>Endpoints that should be included in this app.</returns>
  private static ImmutableArray<RouteDefinition> FilterEndpointsForApp
  (
    AppModel app,
    ImmutableArray<RouteDefinition> allEndpoints
  )
  {
    // If DiscoverEndpoints() was called, include all endpoints
    if (app.DiscoverEndpoints)
      return allEndpoints;

    // If explicit Map<T>() calls, include only those endpoints
    if (!app.ExplicitEndpointTypes.IsDefaultOrEmpty && app.ExplicitEndpointTypes.Length > 0)
    {
      return
      [
        .. allEndpoints.Where
        (
          e => app.ExplicitEndpointTypes.Any
          (
            t => e.Handler.FullTypeName?.EndsWith(t, StringComparison.Ordinal) == true ||
                 e.Handler.FullTypeName == t
          )
        )
      ];
    }

    // Default: no endpoints (test isolation)
    return [];
  }

  /// <summary>
  /// Emits handling for built-in flags (--help, --version, --capabilities).
  /// </summary>
  private static void EmitBuiltInFlags(StringBuilder sb, AppModel app)
  {
    // --help flag
    if (app.HasHelp)
    {
      sb.AppendLine("    // Built-in: --help");
      sb.AppendLine("    if (routeArgs is [\"--help\" or \"-h\"])");
      sb.AppendLine("    {");
      sb.AppendLine("      PrintHelp(app.Terminal);");
      sb.AppendLine("      return 0;");
      sb.AppendLine("    }");
      sb.AppendLine();
    }

    // --version flag (always available)
    sb.AppendLine("    // Built-in: --version");
    sb.AppendLine("    if (routeArgs is [\"--version\"])");
    sb.AppendLine("    {");
    sb.AppendLine("      PrintVersion(app.Terminal);");
    sb.AppendLine("      return 0;");
    sb.AppendLine("    }");
    sb.AppendLine();

    // --capabilities flag (always available for AI tools)
    sb.AppendLine("    // Built-in: --capabilities (for AI tools)");
    sb.AppendLine("    if (routeArgs is [\"--capabilities\"])");
    sb.AppendLine("    {");
    sb.AppendLine("      PrintCapabilities(app.Terminal);");
    sb.AppendLine("      return 0;");
    sb.AppendLine("    }");
    sb.AppendLine();

    // --check-updates flag (opt-in via AddCheckUpdatesRoute())
    if (app.HasCheckUpdatesRoute)
    {
      sb.AppendLine("    // Built-in: --check-updates (opt-in via AddCheckUpdatesRoute())");
      sb.AppendLine("    if (routeArgs is [\"--check-updates\"])");
      sb.AppendLine("    {");
      sb.AppendLine("      await CheckForUpdatesAsync(app.Terminal).ConfigureAwait(false);");
      sb.AppendLine("      return 0;");
      sb.AppendLine("    }");
      sb.AppendLine();
    }
  }

  /// <summary>
  /// Emits code to filter out configuration override args before route matching.
  /// Config overrides are identified by: --key=value, --Section:Key=value, /key=value, /Section:Key=value
  /// This allows AddCommandLine(args) to process them while route matching ignores them.
  /// </summary>
  private static void EmitConfigArgFiltering(StringBuilder sb)
  {
    sb.AppendLine("    // Filter out configuration override args before route matching");
    sb.AppendLine("    // Config overrides: --key=value, --Section:Key=value, /key=value, /Section:Key=value");
    sb.AppendLine("    // Original args are still passed to AddCommandLine() for configuration");
    sb.AppendLine("    static bool IsConfigArg(string arg)");
    sb.AppendLine("    {");
    sb.AppendLine("      if (arg.StartsWith(\"--\", global::System.StringComparison.Ordinal))");
    sb.AppendLine("      {");
    sb.AppendLine("        int eqIdx = arg.IndexOf('=');");
    sb.AppendLine("        int colonIdx = arg.IndexOf(':');");
    sb.AppendLine("        return (eqIdx > 2) || (colonIdx > 2);");
    sb.AppendLine("      }");
    sb.AppendLine("      if (arg.StartsWith(\"/\", global::System.StringComparison.Ordinal) && arg.Length > 1 && char.IsLetter(arg[1]))");
    sb.AppendLine("      {");
    sb.AppendLine("        int eqIdx = arg.IndexOf('=');");
    sb.AppendLine("        int colonIdx = arg.IndexOf(':');");
    sb.AppendLine("        return (eqIdx > 1) || (colonIdx > 1);");
    sb.AppendLine("      }");
    sb.AppendLine("      return false;");
    sb.AppendLine("    }");
    sb.AppendLine("    string[] routeArgs = [.. args.Where(arg => !IsConfigArg(arg))];");
    sb.AppendLine();
  }

  /// <summary>
  /// Emits the no-match fallback code.
  /// </summary>
  private static void EmitNoMatch(StringBuilder sb)
  {
    sb.AppendLine("    // No route matched");
    sb.AppendLine("    await app.Terminal.WriteErrorLineAsync(\"Unknown command. Use --help for usage.\").ConfigureAwait(false);");
    sb.AppendLine("    return 1;");
  }

  /// <summary>
  /// Emits the closing of the class and helper methods.
  /// </summary>
  private static void EmitClassEnd(StringBuilder sb, GeneratorModel model)
  {
    sb.AppendLine();

    // Create a combined AppModel for helper method emission
    // These helpers (PrintHelp, PrintVersion, etc.) need route info from all apps
    AppModel combinedForHelpers = CreateCombinedAppModelForHelpers(model);

    HelpEmitter.Emit(sb, combinedForHelpers);
    sb.AppendLine();
    VersionEmitter.Emit(sb, combinedForHelpers);
    sb.AppendLine();
    CapabilitiesEmitter.Emit(sb, combinedForHelpers);

    if (model.HasCheckUpdatesRoute)
    {
      sb.AppendLine();
      CheckUpdatesEmitter.Emit(sb, combinedForHelpers);
    }

    sb.AppendLine("}"); // Close class
    sb.AppendLine("}"); // Close namespace
  }

  /// <summary>
  /// Creates a combined AppModel for emitting helper methods.
  /// Helper methods (PrintHelp, PrintVersion, etc.) need aggregated data from all apps.
  /// </summary>
  private static AppModel CreateCombinedAppModelForHelpers(GeneratorModel model)
  {
    // Combine all routes for help output
    ImmutableArray<RouteDefinition> allRoutes = [.. model.AllRoutes];

    return new AppModel(
      VariableName: null,
      Name: model.Name,
      Description: model.Description,
      AiPrompt: model.AiPrompt,
      HasHelp: model.HasHelp,
      HelpOptions: model.HelpOptions,
      HasRepl: model.HasRepl,
      ReplOptions: model.ReplOptions,
      HasConfiguration: model.HasConfiguration,
      HasCheckUpdatesRoute: model.HasCheckUpdatesRoute,
      Routes: allRoutes,
      Behaviors: [.. model.AllBehaviors],
      Services: [.. model.AllServices],
      InterceptSites: [], // Not needed for helpers
      UserUsings: model.UserUsings,
      CustomConverters: [.. model.AllConverters],
      LoggingConfiguration: null); // Combined model doesn't use logging config
  }
}
