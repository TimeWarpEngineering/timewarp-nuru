// Main emitter that generates the RunAsync interceptor method.
// This is the entry point for code emission, coordinating all other emitters.

namespace TimeWarp.Nuru.Generators;

using System.Text;

/// <summary>
/// Emits the complete generated interceptor source file.
/// This is the main entry point for the emission phase.
/// </summary>
internal static class InterceptorEmitter
{
  /// <summary>
  /// Generates the complete source code for the interceptor.
  /// </summary>
  /// <param name="model">The application model containing all route definitions.</param>
  /// <returns>The generated C# source code.</returns>
  public static string Emit(AppModel model)
  {
    StringBuilder sb = new();

    EmitHeader(sb);
    EmitInterceptsLocationAttribute(sb);
    EmitNamespaceAndUsings(sb);
    EmitClassStart(sb);
    EmitServiceFields(sb, model.Services);
    EmitInterceptsLocation(sb, model.InterceptSites);
    EmitMethodSignature(sb);
    EmitMethodBody(sb, model);
    EmitClassEnd(sb, model);

    return sb.ToString();
  }

  /// <summary>
  /// Emits the InterceptsLocationAttribute definition.
  /// In .NET 10 / C# 14, interceptors use the new versioned constructor:
  /// InterceptsLocationAttribute(int version, string data)
  /// We use 'file' scope so it doesn't conflict with other generators that may define it.
  /// </summary>
  private static void EmitInterceptsLocationAttribute(StringBuilder sb)
  {
    sb.AppendLine("namespace System.Runtime.CompilerServices");
    sb.AppendLine("{");
    sb.AppendLine("  [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]");
    sb.AppendLine("  file sealed class InterceptsLocationAttribute : global::System.Attribute");
    sb.AppendLine("  {");
    sb.AppendLine("    public InterceptsLocationAttribute(int version, string data)");
    sb.AppendLine("    {");
    sb.AppendLine("      Version = version;");
    sb.AppendLine("      Data = data;");
    sb.AppendLine("    }");
    sb.AppendLine();
    sb.AppendLine("    public int Version { get; }");
    sb.AppendLine("    public string Data { get; }");
    sb.AppendLine("  }");
    sb.AppendLine("}");
    sb.AppendLine();
  }

  /// <summary>
  /// Emits the auto-generated header comment, pragma warning disable, and nullable enable.
  /// </summary>
  private static void EmitHeader(StringBuilder sb)
  {
    sb.AppendLine("// <auto-generated/>");
    sb.AppendLine("// This code was generated by TimeWarp.Nuru V2 source generator.");
    sb.AppendLine("// Do not modify this file directly.");
    sb.AppendLine("#pragma warning disable");
    sb.AppendLine("#nullable enable");
    sb.AppendLine();
  }

  /// <summary>
  /// Emits the namespace declaration and using statements.
  /// Uses block-scoped namespace to be compatible with the InterceptsLocationAttribute
  /// which is in a separate namespace block in the same file.
  /// </summary>
  private static void EmitNamespaceAndUsings(StringBuilder sb)
  {
    sb.AppendLine("namespace TimeWarp.Nuru.Generated");
    sb.AppendLine("{");
    sb.AppendLine();
sb.AppendLine("using global::System.Linq;");
sb.AppendLine("using global::System.Net.Http;");
sb.AppendLine("using global::System.Reflection;");
sb.AppendLine("using global::System.Runtime.CompilerServices;");
sb.AppendLine("using global::System.Text.Json;");
sb.AppendLine("using global::System.Text.Json.Serialization;");
sb.AppendLine("using global::System.Text.RegularExpressions;");
sb.AppendLine("using global::System.Threading.Tasks;");
sb.AppendLine("using global::Microsoft.Extensions.Configuration;");
sb.AppendLine("using global::Microsoft.Extensions.Configuration.Json;");
sb.AppendLine("using global::Microsoft.Extensions.Configuration.EnvironmentVariables;");
sb.AppendLine("#if DEBUG");
sb.AppendLine("using global::Microsoft.Extensions.Configuration.UserSecrets;");
sb.AppendLine("#endif");
sb.AppendLine("using global::TimeWarp.Nuru;");
sb.AppendLine("using global::TimeWarp.Terminal;");
    sb.AppendLine();
  }

  /// <summary>
  /// Emits the file-scoped static class declaration.
  /// </summary>
  private static void EmitClassStart(StringBuilder sb)
  {
    sb.AppendLine("file static class GeneratedInterceptor");
    sb.AppendLine("{");
  }

  /// <summary>
  /// Emits static Lazy fields for Singleton and Scoped services.
  /// These provide thread-safe lazy initialization for cached service instances.
  /// </summary>
  private static void EmitServiceFields(StringBuilder sb, ImmutableArray<ServiceDefinition> services)
  {
    // Only emit fields for Singleton and Scoped services (not Transient)
    // Materialize to array to avoid multiple enumeration
    ServiceDefinition[] cachedServices =
    [
      .. services
        .Where(s => s.Lifetime is ServiceLifetime.Singleton or ServiceLifetime.Scoped)
        .DistinctBy(s => s.ImplementationTypeName) // Avoid duplicates if same impl registered multiple times
    ];

    if (cachedServices.Length == 0)
      return;

    sb.AppendLine("  // Static service fields (thread-safe lazy initialization)");

    foreach (ServiceDefinition service in cachedServices)
    {
      string fieldName = GetServiceFieldName(service.ImplementationTypeName);
      sb.AppendLine(CultureInfo.InvariantCulture,
        $"  private static readonly global::System.Lazy<{service.ImplementationTypeName}> {fieldName} = new(() => new {service.ImplementationTypeName}());");
    }

    sb.AppendLine();
  }

  /// <summary>
  /// Gets the static field name for a service implementation type.
  /// </summary>
  /// <param name="implementationTypeName">Fully qualified implementation type name.</param>
  /// <returns>Field name like "__svc_MyApp_Services_Greeter".</returns>
  internal static string GetServiceFieldName(string implementationTypeName)
  {
    string name = implementationTypeName;

    // Remove global:: prefix
    if (name.StartsWith("global::", StringComparison.Ordinal))
      name = name[8..];

    // Replace dots with underscores for valid C# identifier
    return "__svc_" + name.Replace(".", "_", StringComparison.Ordinal);
  }

  /// <summary>
  /// Emits [InterceptsLocation] attributes for all RunAsync call sites.
  /// Uses the new .NET 10 / C# 14 versioned encoding via InterceptableLocation.
  /// </summary>
  private static void EmitInterceptsLocation(StringBuilder sb, ImmutableArray<InterceptSiteModel> sites)
  {
    // Emit an attribute for each call site so all RunAsync calls are intercepted
    foreach (InterceptSiteModel site in sites)
    {
      // Use the Roslyn-generated attribute syntax which handles all encoding
      // Format: [global::System.Runtime.CompilerServices.InterceptsLocationAttribute(version, "data")]
      sb.AppendLine(CultureInfo.InvariantCulture, $"  {site.GetAttributeSyntax()}");
    }
  }

  /// <summary>
  /// Emits the method signature for the intercepted RunAsync method.
  /// Must match the original NuruCoreApp.RunAsync(string[] args) signature exactly.
  /// </summary>
  private static void EmitMethodSignature(StringBuilder sb)
  {
    sb.AppendLine("  public static async Task<int> RunAsync_Intercepted");
    sb.AppendLine("  (");
    sb.AppendLine("    this NuruCoreApp app,");
    sb.AppendLine("    string[] args");
    sb.AppendLine("  )");
    sb.AppendLine("  {");
  }

  /// <summary>
  /// Emits the complete method body including all route matching logic.
  /// </summary>
  private static void EmitMethodBody(StringBuilder sb, AppModel model)
  {
    // Configuration setup (if AddConfiguration was called)
    if (model.HasConfiguration)
    {
      ConfigurationEmitter.Emit(sb);
    }

    // Built-in flags: --help, --version, --capabilities
    EmitBuiltInFlags(sb, model);

    // Route matching - emit in specificity order (highest first)
    int routeIndex = 0;
    foreach (RouteDefinition route in model.RoutesBySpecificity)
    {
      RouteMatcherEmitter.Emit(sb, route, routeIndex, model.Services);
      routeIndex++;
    }

    // No match fallback
    EmitNoMatch(sb);
  }

  /// <summary>
  /// Emits handling for built-in flags (--help, --version, --capabilities).
  /// </summary>
  private static void EmitBuiltInFlags(StringBuilder sb, AppModel model)
  {
    // --help flag
    if (model.HasHelp)
    {
      sb.AppendLine("    // Built-in: --help");
      sb.AppendLine("    if (args is [\"--help\" or \"-h\"])");
      sb.AppendLine("    {");
      sb.AppendLine("      PrintHelp(app.Terminal);");
      sb.AppendLine("      return 0;");
      sb.AppendLine("    }");
      sb.AppendLine();
    }

    // --version flag (always available)
    sb.AppendLine("    // Built-in: --version");
    sb.AppendLine("    if (args is [\"--version\"])");
    sb.AppendLine("    {");
    sb.AppendLine("      PrintVersion(app.Terminal);");
    sb.AppendLine("      return 0;");
    sb.AppendLine("    }");
    sb.AppendLine();

    // --capabilities flag (always available for AI tools)
    sb.AppendLine("    // Built-in: --capabilities (for AI tools)");
    sb.AppendLine("    if (args is [\"--capabilities\"])");
    sb.AppendLine("    {");
    sb.AppendLine("      PrintCapabilities(app.Terminal);");
    sb.AppendLine("      return 0;");
    sb.AppendLine("    }");
    sb.AppendLine();

    // --check-updates flag (opt-in via AddCheckUpdatesRoute())
    if (model.HasCheckUpdatesRoute)
    {
      sb.AppendLine("    // Built-in: --check-updates (opt-in via AddCheckUpdatesRoute())");
      sb.AppendLine("    if (args is [\"--check-updates\"])");
      sb.AppendLine("    {");
      sb.AppendLine("      await CheckForUpdatesAsync(app.Terminal).ConfigureAwait(false);");
      sb.AppendLine("      return 0;");
      sb.AppendLine("    }");
      sb.AppendLine();
    }
  }

  /// <summary>
  /// Emits the no-match fallback code.
  /// </summary>
  private static void EmitNoMatch(StringBuilder sb)
  {
    sb.AppendLine("    // No route matched");
    sb.AppendLine("    await app.Terminal.WriteErrorLineAsync(\"Unknown command. Use --help for usage.\").ConfigureAwait(false);");
    sb.AppendLine("    return 1;");
    sb.AppendLine("  }");
  }

  /// <summary>
  /// Emits the closing of the class and helper methods.
  /// </summary>
  private static void EmitClassEnd(StringBuilder sb, AppModel model)
  {
    sb.AppendLine();
    HelpEmitter.Emit(sb, model);
    sb.AppendLine();
    VersionEmitter.Emit(sb, model);
    sb.AppendLine();
    CapabilitiesEmitter.Emit(sb, model);

    if (model.HasCheckUpdatesRoute)
    {
      sb.AppendLine();
      CheckUpdatesEmitter.Emit(sb, model);
    }

    sb.AppendLine("}"); // Close class
    sb.AppendLine("}"); // Close namespace
  }
}
