namespace TimeWarp.Nuru;

/// <summary>
/// Delegate type for synchronous invokers generated by the source generator.
/// </summary>
/// <param name="handler">The delegate to invoke.</param>
/// <param name="args">The arguments to pass to the delegate.</param>
/// <returns>The return value of the delegate, or null for void delegates.</returns>
public delegate object? SyncInvoker(Delegate handler, object?[] args);

/// <summary>
/// Delegate type for asynchronous invokers generated by the source generator.
/// </summary>
/// <param name="handler">The delegate to invoke.</param>
/// <param name="args">The arguments to pass to the delegate.</param>
/// <returns>A task containing the return value of the delegate, or null for void async delegates.</returns>
public delegate Task<object?> AsyncInvoker(Delegate handler, object?[] args);

/// <summary>
/// Static registry for source-generated typed invokers.
/// The source generator populates this registry via module initializers.
/// </summary>
public static class InvokerRegistry
{
  private static readonly Dictionary<string, SyncInvoker> SyncInvokers = new(StringComparer.Ordinal);
  private static readonly Dictionary<string, AsyncInvoker> AsyncInvokers = new(StringComparer.Ordinal);
  private static readonly object LockObject = new();

  /// <summary>
  /// Registers a synchronous invoker for a given signature key.
  /// Called by source-generated module initializers.
  /// </summary>
  /// <param name="signatureKey">The unique identifier for the delegate signature.</param>
  /// <param name="invoker">The typed invoker function.</param>
  public static void RegisterSync(string signatureKey, SyncInvoker invoker)
  {
    lock (LockObject)
    {
      SyncInvokers[signatureKey] = invoker;
    }
  }

  /// <summary>
  /// Registers an asynchronous invoker for a given signature key.
  /// Called by source-generated module initializers.
  /// </summary>
  /// <param name="signatureKey">The unique identifier for the delegate signature.</param>
  /// <param name="invoker">The typed invoker function.</param>
  public static void RegisterAsyncInvoker(string signatureKey, AsyncInvoker invoker)
  {
    lock (LockObject)
    {
      AsyncInvokers[signatureKey] = invoker;
    }
  }

  /// <summary>
  /// Registers multiple synchronous invokers at once.
  /// Called by source-generated module initializers.
  /// </summary>
  /// <param name="invokers">Dictionary mapping signature keys to invokers.</param>
  public static void RegisterSyncBatch(IReadOnlyDictionary<string, Func<Delegate, object?[], object?>> invokers)
  {
    ArgumentNullException.ThrowIfNull(invokers);

    lock (LockObject)
    {
      foreach (KeyValuePair<string, Func<Delegate, object?[], object?>> kvp in invokers)
      {
        SyncInvokers[kvp.Key] = new SyncInvoker(kvp.Value);
      }
    }
  }

  /// <summary>
  /// Registers multiple asynchronous invokers at once.
  /// Called by source-generated module initializers.
  /// </summary>
  /// <param name="invokers">Dictionary mapping signature keys to invokers.</param>
  public static void RegisterAsyncInvokerBatch(IReadOnlyDictionary<string, Func<Delegate, object?[], Task<object?>>> invokers)
  {
    ArgumentNullException.ThrowIfNull(invokers);

    lock (LockObject)
    {
      foreach (KeyValuePair<string, Func<Delegate, object?[], Task<object?>>> kvp in invokers)
      {
        AsyncInvokers[kvp.Key] = new AsyncInvoker(kvp.Value);
      }
    }
  }

  /// <summary>
  /// Attempts to get a synchronous invoker for the given signature key.
  /// </summary>
  /// <param name="signatureKey">The signature key to look up.</param>
  /// <param name="invoker">The invoker if found, null otherwise.</param>
  /// <returns>True if an invoker was found, false otherwise.</returns>
  public static bool TryGetSync(string signatureKey, [NotNullWhen(true)] out SyncInvoker? invoker)
  {
    lock (LockObject)
    {
      return SyncInvokers.TryGetValue(signatureKey, out invoker);
    }
  }

  /// <summary>
  /// Attempts to get an asynchronous invoker for the given signature key.
  /// </summary>
  /// <param name="signatureKey">The signature key to look up.</param>
  /// <param name="invoker">The invoker if found, null otherwise.</param>
  /// <returns>True if an invoker was found, false otherwise.</returns>
  public static bool TryGetAsyncInvoker(string signatureKey, [NotNullWhen(true)] out AsyncInvoker? invoker)
  {
    lock (LockObject)
    {
      return AsyncInvokers.TryGetValue(signatureKey, out invoker);
    }
  }

  /// <summary>
  /// Gets the number of registered synchronous invokers (for diagnostics).
  /// </summary>
  public static int SyncCount
  {
    get
    {
      lock (LockObject)
      {
        return SyncInvokers.Count;
      }
    }
  }

  /// <summary>
  /// Gets the number of registered asynchronous invokers (for diagnostics).
  /// </summary>
  public static int AsyncCount
  {
    get
    {
      lock (LockObject)
      {
        return AsyncInvokers.Count;
      }
    }
  }

  /// <summary>
  /// Clears all registered invokers. Useful for testing.
  /// </summary>
  internal static void Clear()
  {
    lock (LockObject)
    {
      SyncInvokers.Clear();
      AsyncInvokers.Clear();
    }
  }

  /// <summary>
  /// Computes the signature key for a method, matching the format used by the source generator.
  /// </summary>
  /// <param name="method">The method to compute the signature key for.</param>
  /// <returns>The signature key string.</returns>
  public static string ComputeSignatureKey(MethodInfo method)
  {
    ArgumentNullException.ThrowIfNull(method);

    System.Text.StringBuilder sb = new();
    ParameterInfo[] parameters = method.GetParameters();

    // Build parameter part of the key
    foreach (ParameterInfo param in parameters)
    {
      if (sb.Length > 0)
        sb.Append('_');

      sb.Append(GetTypeIdentifier(param.ParameterType));
    }

    // Add return type if not void
    Type returnType = method.ReturnType;
    if (returnType != typeof(void))
    {
      sb.Append("_Returns_");
      sb.Append(GetTypeIdentifier(returnType));
    }

    // Handle no parameters and void return
    if (sb.Length == 0)
      return "NoParams";

    return sb.ToString();
  }

  private static string GetTypeIdentifier(Type type)
  {
    // Handle nullable value types
    Type? underlyingNullable = Nullable.GetUnderlyingType(type);
    if (underlyingNullable is not null)
    {
      return "Nullable" + GetSimpleTypeName(underlyingNullable);
    }

    // Handle arrays
    if (type.IsArray)
    {
      Type elementType = type.GetElementType()!;
      return GetSimpleTypeName(elementType) + "ArrayArray";
    }

    // Handle Task and Task<T>
    if (type == typeof(Task))
    {
      return "Task";
    }

    if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Task<>))
    {
      Type resultType = type.GetGenericArguments()[0];
      return "Task" + GetSimpleTypeName(resultType);
    }

    return GetSimpleTypeName(type);
  }

  private static string GetSimpleTypeName(Type type)
  {
    // Map common types to simple names matching the source generator
    return type.Name switch
    {
      "String" => "String",
      "Int32" => "Int",
      "Int64" => "Long",
      "Single" => "Float",
      "Double" => "Double",
      "Boolean" => "Bool",
      "Decimal" => "Decimal",
      "DateTime" => "DateTime",
      "DateTimeOffset" => "DateTimeOffset",
      "TimeSpan" => "TimeSpan",
      "Guid" => "Guid",
      "Byte" => "Byte",
      "SByte" => "SByte",
      "Int16" => "Short",
      "UInt16" => "UShort",
      "UInt32" => "UInt",
      "UInt64" => "ULong",
      "Char" => "Char",
      _ => type.Name
    };
  }
}
