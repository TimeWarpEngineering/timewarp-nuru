// Emits runtime C# code from RouteDefinition.
//
// This emitter generates code that instantiates EXISTING runtime types
// (LiteralMatcher, ParameterMatcher, OptionMatcher, CompiledRoute, Endpoint) from
// TimeWarp.Nuru namespace. It does NOT generate new type definitions.
//
// See: .agent/workspace/2024-12-24T18-30-00_v2-generator-runtime-types-analysis.md
// See: .agent/workspace/2024-12-24T22-45-00_v2-source-generator-flow.md

namespace TimeWarp.Nuru.SourceGen;

using System.Text;

/// <summary>
/// Information needed to emit an endpoint, combining RouteDefinition with handler code.
/// </summary>
/// <param name="Route">The route definition.</param>
/// <param name="HandlerCode">The C# code for the handler (lambda syntax as string), or null for mediator routes.</param>
/// <param name="CommandTypeName">For mediator routes, the fully qualified command type name.</param>
internal sealed record EndpointEmitInfo(
  RouteDefinition Route,
  string? HandlerCode,
  string? CommandTypeName);

/// <summary>
/// Emits runtime C# code from EndpointEmitInfo.
/// Generates code that instantiates existing TimeWarp.Nuru runtime types.
/// </summary>
internal static class RuntimeCodeEmitter
{
  /// <summary>
  /// Configuration for code emission.
  /// </summary>
  internal record EmitOptions(
    string Namespace = "TimeWarp.Nuru.Generated",
    string ClassName = "GeneratedEndpoints",
    int IndentSpaces = 2);

  /// <summary>
  /// Result of emitting code.
  /// </summary>
  internal record EmitResult(
    string SourceCode,
    string FileName);

  /// <summary>
  /// Emits a complete source file with all endpoints.
  /// </summary>
  public static EmitResult EmitSourceFile(
    IEnumerable<EndpointEmitInfo> endpoints,
    EmitOptions? options = null)
  {
    options ??= new EmitOptions();
    StringBuilder sb = new();

    // File header
    sb.AppendLine("// <auto-generated/>");
    sb.AppendLine("#nullable enable");
    sb.AppendLine("// This code was generated by TimeWarp.Nuru V2 source generator.");
    sb.AppendLine("// Do not modify this file directly.");
    sb.AppendLine();

    // Usings - reference existing runtime types
    sb.AppendLine("using System;");
    sb.AppendLine("using System.Collections.Generic;");
    sb.AppendLine("using System.Reflection;");
    sb.AppendLine("using TimeWarp.Nuru;");
    sb.AppendLine();

    // Namespace
    AppendLine(sb, "namespace {0};", options.Namespace);
    sb.AppendLine();

    // Main generated class
    string indent = new(' ', options.IndentSpaces);
    AppendLine(sb, "internal static class {0}", options.ClassName);
    sb.AppendLine("{");

    // Emit each endpoint as a static field
    int endpointIndex = 0;
    List<string> endpointFieldNames = [];

    foreach (EndpointEmitInfo endpoint in endpoints)
    {
      string fieldName = string.Format(CultureInfo.InvariantCulture, "Endpoint_{0}", endpointIndex);
      endpointFieldNames.Add(fieldName);
      EmitEndpointField(sb, endpoint, fieldName, options.IndentSpaces);
      sb.AppendLine();
      endpointIndex++;
    }

    // Emit the All array
    AppendLine(sb, "{0}/// <summary>", indent);
    AppendLine(sb, "{0}/// All endpoints, pre-sorted by specificity (highest first).", indent);
    AppendLine(sb, "{0}/// </summary>", indent);
    AppendLine(sb, "{0}internal static readonly Endpoint[] All =", indent);
    AppendLine(sb, "{0}[", indent);

    string indent2 = new(' ', options.IndentSpaces * 2);
    for (int i = 0; i < endpointFieldNames.Count; i++)
    {
      string comma = i < endpointFieldNames.Count - 1 ? "," : "";
      AppendLine(sb, "{0}{1}{2}", indent2, endpointFieldNames[i], comma);
    }

    AppendLine(sb, "{0}];", indent);

    sb.AppendLine("}");

    return new EmitResult(
      SourceCode: sb.ToString(),
      FileName: string.Format(CultureInfo.InvariantCulture, "{0}.g.cs", options.ClassName));
  }

  /// <summary>
  /// Emits a single endpoint as a static field using existing Endpoint type.
  /// </summary>
  private static void EmitEndpointField(
    StringBuilder sb,
    EndpointEmitInfo endpoint,
    string fieldName,
    int indentSpaces)
  {
    RouteDefinition route = endpoint.Route;
    string indent = new(' ', indentSpaces);
    string indent2 = new(' ', indentSpaces * 2);
    string indent3 = new(' ', indentSpaces * 3);
    string indent4 = new(' ', indentSpaces * 4);

    AppendLine(sb, "{0}/// <summary>", indent);
    AppendLine(sb, "{0}/// Route: {1}", indent, EscapeXmlComment(route.OriginalPattern));

    if (route.Description is not null)
    {
      AppendLine(sb, "{0}/// {1}", indent, EscapeXmlComment(route.Description));
    }

    AppendLine(sb, "{0}/// </summary>", indent);

    AppendLine(sb, "{0}private static readonly Endpoint {1} = new()", indent, fieldName);
    AppendLine(sb, "{0}{{", indent);

    // RoutePattern
    AppendLine(sb, "{0}RoutePattern = \"{1}\",", indent2, EscapeString(route.OriginalPattern));

    // CompiledRoute
    AppendLine(sb, "{0}CompiledRoute = new CompiledRoute()", indent2);
    AppendLine(sb, "{0}{{", indent2);

    // Segments array using existing RouteMatcher types
    AppendLine(sb, "{0}Segments = new RouteMatcher[]", indent3);
    AppendLine(sb, "{0}{{", indent3);
    EmitSegmentMatchers(sb, route.Segments, indentSpaces * 4);
    AppendLine(sb, "{0}}},", indent3);

    // MessageType
    string messageType = route.MessageType switch
    {
      "Query" => "MessageType.Query",
      "IdempotentCommand" => "MessageType.IdempotentCommand",
      _ => "MessageType.Command"
    };
    AppendLine(sb, "{0}MessageType = {1},", indent3, messageType);

    // Specificity
    AppendLine(sb, "{0}Specificity = {1},", indent3, route.ComputedSpecificity);

    // CatchAllParameterName if present
    string? catchAllName = GetCatchAllParameterName(route.Segments);
    if (catchAllName is not null)
    {
      AppendLine(sb, "{0}CatchAllParameterName = \"{1}\",", indent3, EscapeString(catchAllName));
    }

    AppendLine(sb, "{0}}},", indent2);

    // Handler - emit the lambda directly if available
    if (endpoint.HandlerCode is not null)
    {
      AppendLine(sb, "{0}Handler = {1},", indent2, endpoint.HandlerCode);
    }

    // CommandType - for mediator routes
    if (endpoint.CommandTypeName is not null)
    {
      AppendLine(sb, "{0}CommandType = typeof({1}),", indent2, endpoint.CommandTypeName);
    }

    // Order (specificity)
    AppendLine(sb, "{0}Order = {1},", indent2, route.ComputedSpecificity);

    // Description
    if (route.Description is not null)
    {
      AppendLine(sb, "{0}Description = \"{1}\",", indent2, EscapeString(route.Description));
    }

    // MessageType on Endpoint
    AppendLine(sb, "{0}MessageType = {1},", indent2, messageType);

    AppendLine(sb, "{0}}};", indent);
  }

  /// <summary>
  /// Emits segment matchers using existing RouteMatcher types.
  /// </summary>
  private static void EmitSegmentMatchers(
    StringBuilder sb,
    IEnumerable<SegmentDefinition> segments,
    int indentSpaces)
  {
    string indent = new(' ', indentSpaces);

    foreach (SegmentDefinition segment in segments)
    {
      switch (segment)
      {
        case LiteralDefinition literal:
          AppendLine(sb, "{0}new LiteralMatcher(\"{1}\"),", indent, EscapeString(literal.Value));
          break;

        case ParameterDefinition param:
          EmitParameterMatcher(sb, param, indent);
          break;

        case OptionDefinition option:
          EmitOptionMatcher(sb, option, indent);
          break;
      }
    }
  }

  /// <summary>
  /// Emits a ParameterMatcher instantiation.
  /// </summary>
  private static void EmitParameterMatcher(StringBuilder sb, ParameterDefinition param, string indent)
  {
    // ParameterMatcher(string name, bool isCatchAll = false, string? constraint = null,
    //                  string? description = null, bool isOptional = false)

    List<string> args = [$"\"{EscapeString(param.Name)}\""];

    // Only add optional parameters if they have non-default values
    bool hasNonDefaultArgs = param.IsCatchAll ||
                              param.TypeConstraint is not null ||
                              param.Description is not null ||
                              param.IsOptional;

    if (hasNonDefaultArgs)
    {
      args.Add(param.IsCatchAll ? "true" : "false");

      if (param.TypeConstraint is not null || param.Description is not null || param.IsOptional)
      {
        args.Add(param.TypeConstraint is not null ? $"\"{EscapeString(param.TypeConstraint)}\"" : "null");
      }

      if (param.Description is not null || param.IsOptional)
      {
        args.Add(param.Description is not null ? $"\"{EscapeString(param.Description)}\"" : "null");
      }

      if (param.IsOptional)
      {
        args.Add("true");
      }
    }

    AppendLine(sb, "{0}new ParameterMatcher({1}),", indent, string.Join(", ", args));
  }

  /// <summary>
  /// Emits an OptionMatcher instantiation.
  /// </summary>
  private static void EmitOptionMatcher(StringBuilder sb, OptionDefinition option, string indent)
  {
    // OptionMatcher(string matchPattern, bool expectsValue = false, string? parameterName = null,
    //               string? alternateForm = null, string? description = null, bool isOptional = false,
    //               bool isRepeated = false, bool parameterIsOptional = false)

    // Use the long form as the match pattern
    string matchPattern = option.LongForm;

    List<string> args = [$"\"{EscapeString(matchPattern)}\""];

    // Check if we need any optional parameters
    bool hasNonDefaultArgs = option.ExpectsValue ||
                              option.ParameterName is not null ||
                              option.ShortForm is not null ||
                              option.Description is not null ||
                              option.IsOptional ||
                              option.IsRepeated ||
                              option.ParameterIsOptional;

    if (hasNonDefaultArgs)
    {
      args.Add(option.ExpectsValue ? "true" : "false");

      if (option.ParameterName is not null || option.ShortForm is not null ||
          option.Description is not null || option.IsOptional ||
          option.IsRepeated || option.ParameterIsOptional)
      {
        args.Add(option.ParameterName is not null ? $"\"{EscapeString(option.ParameterName)}\"" : "null");
      }

      if (option.ShortForm is not null || option.Description is not null ||
          option.IsOptional || option.IsRepeated || option.ParameterIsOptional)
      {
        args.Add(option.ShortForm is not null ? $"\"{EscapeString(option.ShortForm)}\"" : "null");
      }

      if (option.Description is not null || option.IsOptional ||
          option.IsRepeated || option.ParameterIsOptional)
      {
        args.Add(option.Description is not null ? $"\"{EscapeString(option.Description)}\"" : "null");
      }

      if (option.IsOptional || option.IsRepeated || option.ParameterIsOptional)
      {
        args.Add(option.IsOptional ? "true" : "false");
      }

      if (option.IsRepeated || option.ParameterIsOptional)
      {
        args.Add(option.IsRepeated ? "true" : "false");
      }

      if (option.ParameterIsOptional)
      {
        args.Add("true");
      }
    }

    AppendLine(sb, "{0}new OptionMatcher({1}),", indent, string.Join(", ", args));
  }

  /// <summary>
  /// Gets the catch-all parameter name if present.
  /// </summary>
  private static string? GetCatchAllParameterName(IEnumerable<SegmentDefinition> segments)
  {
    foreach (SegmentDefinition segment in segments)
    {
      if (segment is ParameterDefinition { IsCatchAll: true } param)
      {
        return param.Name;
      }
    }

    return null;
  }

  /// <summary>
  /// Helper to append a formatted line using invariant culture.
  /// </summary>
  private static void AppendLine(StringBuilder sb, string format, params object[] args)
  {
    string formatted = string.Format(CultureInfo.InvariantCulture, format, args);
    sb.Append(formatted);
    sb.AppendLine();
  }

  /// <summary>
  /// Escapes a string for use in C# source code.
  /// </summary>
  private static string EscapeString(string value)
  {
    return value
      .Replace("\\", "\\\\", StringComparison.Ordinal)
      .Replace("\"", "\\\"", StringComparison.Ordinal)
      .Replace("\n", "\\n", StringComparison.Ordinal)
      .Replace("\r", "\\r", StringComparison.Ordinal)
      .Replace("\t", "\\t", StringComparison.Ordinal);
  }

  /// <summary>
  /// Escapes text for use in XML comments.
  /// </summary>
  private static string EscapeXmlComment(string value)
  {
    return value
      .Replace("&", "&amp;", StringComparison.Ordinal)
      .Replace("<", "&lt;", StringComparison.Ordinal)
      .Replace(">", "&gt;", StringComparison.Ordinal);
  }
}
