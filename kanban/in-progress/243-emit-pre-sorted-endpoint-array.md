# Emit pre-sorted Endpoint array

## Parent

#239 Epic: Compile-time endpoint generation

## Description

Modify the source generator to emit a pre-sorted `Endpoint[]` array instead of using `NuruRouteRegistry.Register()` calls. The array is sorted by specificity at compile time, eliminating runtime sorting.

## Requirements

- Generator emits `static readonly Endpoint[] All = [...]`
- Endpoints pre-sorted by Order desc, then Specificity desc
- All `CompiledRoute` data inlined (no builder calls at runtime)
- Replace `NuruRouteRegistry` usage with direct array access

## Checklist

- [x] Modify generator to collect all routes into design-time model
- [x] Sort routes by specificity during generation
- [x] Emit `GeneratedEndpoints` static class with pre-sorted array
- [x] Emit `CompiledRoute` instances inline (not via builder)
- [x] Emit `RouteMatcher` instances inline
- [ ] Update `Build()` to use generated array instead of registry
- [ ] Verify matching behavior unchanged

## Notes

### Generated Output Example

```csharp
// <auto-generated/>
namespace TimeWarp.Nuru.Generated;

internal static class GeneratedEndpoints
{
    internal static readonly Endpoint[] All =
    [
        // Pre-sorted by specificity (highest first)
        new Endpoint
        {
            RoutePattern = "add {a:int} {b:int}",
            CompiledRoute = new CompiledRoute
            {
                Segments =
                [
                    new LiteralMatcher("add"),
                    new ParameterMatcher("a", isCatchAll: false, "int"),
                    new ParameterMatcher("b", isCatchAll: false, "int"),
                ],
                Specificity = 140,
                MessageType = MessageType.Query
            },
            Description = "Adds two numbers",
            // Handler bound separately
        },
        // ... more endpoints
    ];
}
```

### What Gets Removed

- `NuruRouteRegistry` runtime registration
- `EndpointCollection.Sort()` runtime call
- Runtime `CompiledRouteBuilder` usage for attributed routes

### Progress (2024-12-24)

**Completed:**
- V2 generator now emits `Endpoint[]` with handlers
- Generated code compiles successfully
- Verified with `routing-01-basic-matching.cs` test (all 9 tests pass)
- Pure lambdas work correctly (`() => "healthy"`, `() => 0`)

**Generated output includes:**
- `Endpoint` objects with `RoutePattern`, `CompiledRoute`, `Handler`, `Order`, `MessageType`
- `CompiledRoute` with `Segments` array of `LiteralMatcher`
- Pre-sorted `Endpoint[] All` array

**Test modification:**
- Updated 3 tests in `routing-01-basic-matching.cs` to use `TestTerminal` and pure lambdas instead of closures
- Closures in handlers are correctly detected by `NURU_H002` analyzer (suppressed in tests)

**Remaining:**
- Wire `Build()` to use `GeneratedEndpoints.All` instead of runtime registry (may be #248 scope)
- Verify matching behavior at runtime with V2-generated endpoints

## Architecture Document

**CRITICAL: Read this before continuing work on V2:**

`.agent/workspace/2024-12-25T01-00-00_v2-generator-architecture.md`

### Key Points

1. **The Goal:** Move all deterministic work to compile time. Only matching (args unknown) and execution happen at runtime.

2. **The Generated Invoker:** V2 generates the invoker as inline code that extracts typed parameters and calls the handler directly. No reflection, no registry lookup.

3. **The Flow:**
   ```
   args[] → Matcher (existing V1 works) → Endpoint → Generated Invoker → result
   ```

4. **Reference Implementation:** `sandbox/experiments/manual-runtime-construction.cs` shows exactly what the generator should produce.

5. **What Changes:** Instead of `Endpoint.Handler` being a `Delegate` that goes through `InvokerRegistry`, the endpoint has a generated `Func<Dictionary<string, object>, object?>` that directly calls the handler logic.
